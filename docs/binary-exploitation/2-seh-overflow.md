# SEH Overflow

!!! note ""

    Les dépassements de tampon basés sur `SEH` exploitent le mécanisme `Structured Exception Handling` mis en oeuvre dans les systèmes Windows.

## Théorie

### Les exceptions

Une exception est un comportement inattendu qui arrive durant l'exécution normale d'un programme.

Il existe 2 types d'exception :

- Materiel : Les exceptions matérielles sont initiées par le `CPU`
    * e.g. : Le `CPU` essaye de faire référence à une adresse mémoire invalide
- Logiciel : Les exceptions matérielles sont initiées par les applications
    * e.g. :  Un développeur veut lever une exception dans le code pour signaler qu'une fonction ne s'est pas exécutée correctement via un bloc `try {} except {}`

La plupart des langages implémentent des fonctionnalités de `try` et `catch` bien que les mots clés puissent varier.

À la suite de la compilation, `try {} except {}` va utiliser le mécanisme `Structure Exception Handling (SEH)` implémenté par Windows pour gérer les événements inattendus.

### Le mécanisme SEH

Le mécanisme `SEH` donne la possibilité aux développeurs de prendre action quand un événement inattendu se réalise durant le flot d'exécution d'un *thread*.

Quand un thread est en défaut le système d'exploitation appelle un ensemble de fonctions prédéfinies nommées *exception handlers*.

Ces fonctions vont fournir des données et tenter de corriger l'exception. Les *exception handlers* sont créées durant la compilation.

À chaque fois qu'un bloc `try` est rencontrée durant l'exécution d'une fonction dans un *thread*, un pointeur vers le *handler* correspondant est stocké sur la pile dans la structure `_EXCEPTION_REGISTRATION_RECORD`.

Comme il peut y avoir plusieurs blocs `try` exécutés dans une fonction ces structures sont liées par une liste chainée.

<p align="center">
  <img src="https://raw.githubusercontent.com/s-lck/HolisticPwning/main/assets/seh_overflow_01.png">
</p>

Quand une exception est levée, le système d'exploitation inspecte la structure `Thread Environmental Block` (`TEB`) du thread impliqué et retrouve le pointeur (`ExceptionList`) vers la liste chainée `_EXCEPTION_REGISTRATION_RECORD` via le registre `FS` du CPU.

Après avoir retrouvé le `ExceptionList` l'OS va appeler chaque *exception handler* jusqu'à ce qu'une d'entre elles puisse gérer l'événement.

Si aucune des fonctions définies par l'utilisateur ne peut gérer l'exception, le système d'exploitation va appeler le *default exception handler* qui est le dernier noeud de la liste chainée.

#### Structures

##### Thread Environmental Block

Structure `TEB` :

```c
0:010> dt nt!_TEB
ntdll!_TEB
   +0x000 NtTib            : _NT_TIB
   +0x01c EnvironmentPointer : Ptr32 Void
   +0x020 ClientId         : _CLIENT_ID
   +0x028 ActiveRpcHandle  : Ptr32 Void
   +0x02c ThreadLocalStoragePointer : Ptr32 Void
   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB
   +0x034 LastErrorValue   : Uint4B
   +0x038 CountOfOwnedCriticalSections : Uint4B
   +0x03c CsrClientThread  : Ptr32 Void
   +0x040 Win32ThreadInfo  : Ptr32 Void
```

On voit que le premier élément de la structure `TEB` est lui-même une structure de type `_NT_TIB`.

##### _NT_TIB

Structure `_NT_TIB` :

```c
0:010> dt _NT_TIB
ntdll!_NT_TIB
   +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD
   +0x004 StackBase        : Ptr32 Void
   +0x008 StackLimit       : Ptr32 Void
   +0x00c SubSystemTib     : Ptr32 Void
   +0x010 FiberData        : Ptr32 Void
   +0x010 Version          : Uint4B
   +0x014 ArbitraryUserPointer : Ptr32 Void
   +0x018 Self             : Ptr32 _NT_TIB
```

##### _EXCEPTION_REGISTRATION_RECORD

Le premier élément de la structure nommé `ExceptionList` est un pointeur sur la structure `_EXCEPTION_REGISTRATION_RECORD` :

```c
0:010> dt _EXCEPTION_REGISTRATION_RECORD
ntdll!_EXCEPTION_REGISTRATION_RECORD
   +0x000 Next             : Ptr32 _EXCEPTION_REGISTRATION_RECORD
   +0x004 Handler          : Ptr32     _EXCEPTION_DISPOSITION
```

* `Next` fais le lien pour la liste chainée et est un pointeur sur la structure `_EXCEPTION_REGISTRATION_RECORD`
* `Handler` est un pointeur vers la fonction *exception callback* nommé `_except_hamdler` qui renvoie une structure `_EXCEPTION_DISPOSITION`

##### _EXCEPTION_DISPOSITION

Structure `_EXCEPTION_DISPOSITION` :

```c
typedef EXCEPTION_DISPOSITION _except_handler (*PEXCEPTION_ROUTINE) (  
    IN PEXCEPTION_RECORD ExceptionRecord,  
    // pointe sur la structure `_EXCEPTION_REGISTRATION_RECORD`
    IN VOID EstablisherFrame,  
    // pointe sur la structure `CONTEXT`
    IN OUT PCONTEXT ContextRecord,  
    IN OUT PDISPATCHER_CONTEXT DispatcherContext  
);
```

La structure `CONTEXT` contiens les données de certains registres du CPU lorsque l'exception est levée, dont le pointeur `EIP`.

Les informations de cette structure vont être utilisées pour restaurer le flot d'exécution après la gestion de l'exception.

- Si le *exception handler* invoqué par l'OS n'est pas valide pour gérer l'exception il va renvoyer `ExceptionContinueSearch`. Va indiquer à l'OS de se déplacer à l'élément suivant de la liste chainée `_EXCEPTION_REGISTRATION_RECORD`.
- Si le *exception handler* est à même de *handle* l'exception il va renvoyer `ExceptionContinueExecution`. Va indiquer à l'OS de relancer l'exécution.

#### Étapes du SEH

Quand une exception est levée, le système d'exploitation appelle un groupe de fonction définie dans le cadre du mécanisme `SEH`.

Au sein de ces appels, la liste chainée `ExceptionList` est récupérée du `TEB`. Le système d'exploitation parse la liste chainée de structures `_EXCEPTION_REGISTRATION_RECORD`. Le système d'exploitation réalise plusieurs contrôles avant d'appeler la fonction `exception_handler` pointe par le membre `Handler` de la structure.

L'iteration de la liste chainée continue jusqu'à ce qu'un *handler* capable de gérer l'exception soit trouvé permettant a l'exécution de continuer. Si aucun *handler* capable n'est trouvé, l'application crash.

#### Protections de SEH

* `SafeSEH` : Mitigation introduite par Microsoft pour empêcher un attaquant de gagner le contrôle du flot d'exécution après avoir réécrit un *exception handler* sur la pile
* `SEHOP` : Vérifie que la chaine de structure `_EXCEPTION_REGISTRATION_RECORD` est valide avant de l'invoquer. Si le paramètre `Next` est réécrit, la structure n'est plus intact. Cette mitigation empêchera le `_except_handler` d'être exécuté.

## Pratique

Un *structure exception overflow* est un type de *stack overflow* qui est assez large ou bien positionne de facon a re-ecrire des *valid registered exception handler* sur la pile. En re-ecrivant un ou plusieurs de ces handlers l'attaquant peut prendre le controle du pointeur d'instruction apres avoir trigger une exception.

Dans la pluspart des cas l'objectif d'un overflow est de re-ecrire des pointeurs valides / structures sur la pile.

:fontawesome-solid-road-barrier:

## Référence

- [SEH Based Buffer Overflow](https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/seh-based-buffer-overflow)
