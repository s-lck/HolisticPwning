# Architecture et debugger

## x86 Architecture

### La mémoire

Quand un programme est exécuté, il alloue de la mémoire en respectant les limites imposées par le système.

Allocation de la mémoire dans Windows entre l'adresse mémoire la plus basse `0x00000000` et l'adresse mémoire la plus haute `0x7FFFFFFF` :

<p align="center">
  <img src="https://raw.githubusercontent.com/s-lck/HolisticPwning/main/assets/architecture_x86_01.png">
</p>

### La pile

Quand un *thread* est en cours d'exécution il a besoin d'une zone de stockage de donnée à cours terme pour :

- les fonctions
- les variables locales
- les informations de contrôle du programme

C'est dans la pile (*stack*) que ces éléments sont stockés.

Pour simplifier l'exécution *multi-thread* chaque *thread* dans une même application utilise une pile différente.

La pile est vu par le CPU comme une memoire de structure `Last-In, First-Out (LIFO)` :

- Les éléments déposés (`pushed`) en haut de la pile sont supprimés (`popped`) en premier
- L'architecture x86 implémente deux instructions Assembleur dédiées
    * `PUSH` : Ajout dans le pile
    * `POP` : Retrait de la pile

### Conventions d'appels

Les conventions d'appels décrivent comment les fonctions reçoivent leurs paramètres depuis leur appelant et comment elles renvoient leur résultat.

L'architecture offre plusieurs conventions d'appels dont les différences sont liées à :

- Comment les paramètres et la valeur de retour sont envoyés
    * Registres CPU
    * Déposé sur la pile
    * Les deux
- Dans quel ordre sont passes les paramètres
- Comment la pile est préparée et nettoyée après l'appel
- Quels registres CPU la fonction appelée doit conserver pour l'appelant

Généralement le compilateur détermine quelle convention d'appel est utilisée pour toutes les fonctions d'un programme. `cdecl` est un exemple de conventions d'appel.

### Retours de fonction

:fontawesome-solid-road-barrier:

## Windows Debugger

:fontawesome-solid-road-barrier:

## Protections

:fontawesome-solid-road-barrier:
