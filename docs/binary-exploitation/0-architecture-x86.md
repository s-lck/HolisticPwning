# Architecture et debugger

## Architecture x86

### La mémoire

Quand un programme est exécuté, il alloue de la mémoire en respectant les limites imposées par le système.

Allocation de la mémoire dans Windows entre l'adresse mémoire la plus basse `0x00000000` et l'adresse mémoire la plus haute `0x7FFFFFFF` :

<p align="center">
  <img src="https://raw.githubusercontent.com/s-lck/HolisticPwning/main/assets/architecture_x86_01.png">
</p>

### La pile

Quand un *thread* est en cours d'exécution il a besoin d'une zone de stockage de donnée à cours terme pour :

- les fonctions
- les variables locales
- les informations de contrôle du programme

C'est dans la pile (*stack*) que ces éléments sont stockés.

Pour simplifier l'exécution *multi-thread* chaque *thread* dans une même application utilise une pile différente.

La pile est vu par le CPU comme une memoire de structure `Last-In, First-Out (LIFO)` :

- Les éléments déposés (`pushed`) en haut de la pile sont supprimés (`popped`) en premier
- L'architecture x86 implémente deux instructions Assembleur dédiées
    * `PUSH` : Ajout dans le pile
    * `POP` : Retrait de la pile

### Conventions d'appels

Les conventions d'appels décrivent comment les fonctions reçoivent leurs paramètres depuis leur appelant et comment elles renvoient leur résultat.

L'architecture offre plusieurs conventions d'appels dont les différences sont liées à :

- Comment les paramètres et la valeur de retour sont envoyés
    * Registres CPU
    * Déposé sur la pile
    * Les deux
- Dans quel ordre sont passés les paramètres
- Comment la pile est préparée et nettoyée après l'appel
- Quels registres CPU la fonction appelée doit conserver pour l'appelant

Généralement le compilateur détermine quelle convention d'appel est utilisée pour toutes les fonctions d'un programme. `cdecl` est un exemple de conventions d'appel.

### Retours de fonction

Quand du code au sein d'un `thread` appelle une fonction il doit connaitre son adresse de retour pour revenir au code appelant une fois la fonction complétée.

L'adresse de retour est stockée dans la pile :

- Avec les paramètres de la fonction
- Ainsi que les variables locales

Ces données sont associées à un appel de fonction et sont stockées dans une section de la `stack` nommée `stack frame`.

<p align="center">
  <img src="https://raw.githubusercontent.com/s-lck/HolisticPwning/main/assets/architecture_x86_02.png">
</p>

Quand une fonction se termine, l'adresse de retour est récupérée depuis la pile et utilisée pour restaurer le flot d'exécution de la fonction appelante.

### Les registres du CPU

Les registres sont de tout petits et très rapides espaces mémoire permettant de lire et manipuler rapidement les données.

Dans une architecture 32 bits le CPU utilise 9 registres de 32 bits.

<p align="center">
  <img src="https://raw.githubusercontent.com/s-lck/HolisticPwning/main/assets/architecture_x86_03.png">
</p>

Les noms ont étaient définis pour l'architecture 16 bits et ont ensuite été étendus pour les plates-formes 32 bits avec la lettre `E`.

Chaque registre peut contenir une valeur de 32 bits entre `0x00000000` et `0xFFFFFFFF` ou bien 16 bits ou 8 bits dans les sous-registres associés.

<p align="center">
  <img src="https://raw.githubusercontent.com/s-lck/HolisticPwning/main/assets/architecture_x86_04.png">
</p>

- `EAX` : *Accumulator* : Opérations logiques et arithmétiques
- `EBX` : *Base* : Pointeur de base adresse mémoire
- `ECX` : *Counter* : Boucle, déplacement, rotation
- `EDX` : *Data* : *Input/Output*, multiplication, division
- `ESI` : *Source Index* : *Pointer addressing of data and source in string copy operations*
- `EDI` : *Destination Index* : *Pointer addressing of data and destination in string copy operations*

#### ESP : Pointeur de pile

La pile permet de stocker des données, des pointeurs et des arguments. La pile évolue en permanence durant l'exécution du programme.

Le pointeur de pile permet de suivre l'évolution de la localisation la plus récente de la pile. Il pointe sur le haut de la pile.

!!! info "Pointeur"

    Un pointeur est une référence vers une adresse en mémoire. Quand on dit qu'un registre contient un pointeur ou pointe sur adresse, cela veut dire que le registre contient l'adresse ciblée.

#### EBP : Pointeur de base

La pile évolue constamment. Il peut devenir compliqué pour une fonction de suivre sa `stack frame` qui contient les arguments requis, les variables locales et l'adresse de retour.

`EBP` va pointer sur le haut de la pile quand la fonction est appelée. La fonction va ensuite pouvoir utiliser `EBP` pour référencer les informations via *offset*.

Chaque bloc est sur 4 octets :

- Si on est a 2 blocs de EBP : `[ebp] + 8`
- Si on est a 4 blocs de EBP :  `[ebp] + 12`

#### EIP : Pointeur d'instructions

Un des registres les plus importants. Ce registre pointe toujours vers la prochaine instruction de code à exécuter.

`EIP` permet de gérer le flot du programme, c'est la cible principale pour les dépassements de tampon.

## Windows Debugger

Il existe plusieurs outils de debug tel que :

- OllyDbg
- Immunity Debugger
- WinDBG

Un debugger est un programme informatique inséré entre une application et le CPU. Un debugger agit comme un proxy. Il permet de voir et d'interagir avec la mémoire et le flot d'exécution.

Le CPU travaille avec du code binaire difficilement lisible par un humain. Le langage `Assembleur` fournis un mappage d’un pour un entre le binaire et le langage de programmation. Langage lisible par un humain.

!!! info "Opcode"

    `Opcode` : Séquence binaire interprétée par le CPU comme une instruction précise.Le debugger affichera la valeur en hexadecimal et en langage assembleur.

### Les symboles

Les fichiers de symboles permettent à WinDBG de référencer les fonctions et structures internes ainsi que les variables globales en utilisant des noms plutôt que des adresses.

On peut utiliser le fichier de symbole de Microsoft pour les exécutables Windows.

Les fichiers de symboles (`.PDB`) sont créés à la compilation par Microsoft de ses fichiers natifs. Microsoft ne fournit pas les fichiers de symbole pour chaque fichier. Les applications tierces peuvent avoir leur fichier `PDB`.

:fontawesome-solid-road-barrier:

## Protections

:fontawesome-solid-road-barrier:
