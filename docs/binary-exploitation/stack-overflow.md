# Stack Overflow

!!! note ""

    Les dépassements de tampon basés sur la pile (*stack*) sont causés par un trop-plein d'écriture au sein d'une variable stockée dans la pile.

## Théorie

Exemple de programme vulnérable à un *stack buffer overflow* :

```c
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
  char buffer[64];

  if (argc < 2)
  {
    printf("Error - You must supply at least one argument\n");
    return 1;
  }
  
  strcpy(buffer, argv[1]);
 
  return 0;
}
```

Ce programme déclare une variable local nommée `buffer` de  64 caractères. Un espace de 64 *bytes* dans la pile va donc être réservé pour cette variable à l'exécution.

Cet espace sera réservé au sein de la *stack frame* de la fonction `main` du programme.

!!! info ""

    Les variables locales ont une *scope* locale et ne sont donc accessibles que dans le cadre de la fonction ou du bloc dans lequel elles sont déclarées. Les variables globales sont stockées dans la section `.data` du programme, se trouvant dans un autre espace mémoire accessible a tout le code.

La fonction `strcpy` définie dans `string.h` copie l'argument fourni en paramètre à `main` dans la variable `buffer`.

Dans le cas de ce programme

- Si l'argument fait 64 *bytes* ou moins, le programme va fonctionner
- Si l'argument fait plus que 64 des parties adjacentes au buffer dans la pile vont être reécrites entrainant un dépassement de mémoire

<p align="center">
  <img src="https://raw.githubusercontent.com/s-lck/HolisticPwning/main/assets/stack_overflow_01.png">
</p>

Si le dépassement de tampon est assez large l'attaquant pourrait être capable de réécrire l'adresse de retour de la fonction vulnérable sur la pile avec de la donnée arbitraire.

Quand une fonction termine son exécution, l'adresse de retour est récupérée depuis la pile et  pour restaurer le flot d'exécution à la fonction appelante

Dans notre exemple :

- Pour la fonction `main` l'adresse de retour réécrite à la suite du dépassement de tampon est mise dans le registre `Extended Instruction Pointer` (`EIP`)
- Le CPU va donc essayer de lire l'adresse de l'instruction suivante à partir de l'adresse dans `EIP`
    * `0x41414141` (`0x41` étant le code hexadécimal de `A`)
- Comme cela n'est pas une adresse valide le CPU va renvoyer une erreur *access violation* et l'application va s'arrêter

Le registre `EIP` est utilisé directement par le CPU pour exécuter du code au niveau assembleur. Obtenir un accès à `EIP` permettrait d'exécuter du code arbitraire.

## Pratique

:fontawesome-solid-road-barrier:

## Référence

- [32-bit Stack-based Buffer Overflow](https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/stack-based-buffer-overflow)
